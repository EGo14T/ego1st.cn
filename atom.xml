<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ego1st.cn/</id>
    <title>ego1st Blog</title>
    <updated>2022-01-08T18:35:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ego1st.cn/"/>
    <subtitle>ego1st Blog</subtitle>
    <icon>https://ego1st.cn/img/favicon.ico</icon>
    <rights>Copyright © 2022 Facebook, Inc.</rights>
    <entry>
        <title type="html"><![CDATA[2021。2022，]]></title>
        <id>/2021</id>
        <link href="https://ego1st.cn/2021"/>
        <updated>2022-01-08T18:35:00.000Z</updated>
        <summary type="html"><![CDATA[2021年，是个不太平的一年，对于许多人来说是非同寻常的一眼，对于我来说，更是如此。]]></summary>
        <content type="html"><![CDATA[<div songid="431259256"></div><p>2021年，是个不太平的一年，对于许多人来说是非同寻常的一眼，对于我来说，更是如此。</p><h2>🤐碎碎念</h2><p>首先是这个博客，今年一年没有发过一篇博客。去年立的<code>Flag</code>是给博客增加评论系统，然后学了<code>Go语言</code>跟<code>React</code>，完成了后端接口跟前端页面，但是无意间打开调试窗口，看到一串一串的报错，血压当场升高，奈何当初博客使用模板语言写的，并不知道怎么解决。然后就找<code>Vue</code>、<code>React</code>相关框架的博客引擎，最后选择了<code>Docusaurus</code>，抱着学习<code>React</code>的心态开始重构之前的博客，前前后后大概花了3个月，直到快2022年才上线使用；调整了一些样式，增加了暗黑模式，使用<code>Git Action</code> 持续化部署，每次更新文章或代码，可以自动打包部署到服务器上，最最重要的是，控制台没！有！报！错！了！😊强迫症直呼太爽。</p><p>说完了博客，再说下今年发生的一些事情</p><p>首先是朋友，走着走着，就形同陌路了。</p><p>再有是我的一个室友离职了，自从他走后，没人跟我侃天侃地侃人生了，有些工作上的不顺心也只能憋到心里，慢慢消化，渐渐的，开始学会享受孤独。每天最放松的时间就是坐在公交车上，听着歌，放空自己。偶尔回家早也会练练字；只是周末的时候也不经常出门，之前还会和离职的室友一起出去逛街，逛公园。也有过想要出门的冲动，有一次，自己出门逛街，走在淮海路上，总觉得自己跟这座城市格格不入，也不知道哪里不对🙃</p><p>还有就是今年更加注重穿着打扮了（更自恋了😎）逛B站会经常去看一些穿搭视频，走路上也会观察路人的穿搭。眼睛：看到了，脑子：学废了。</p><p>今年算是工作一年了，不像去年那么懵懂，在工作上也能独当一面了；看到今年入职的新员工，就像看到去年的自己。觉得自己也该成熟起来，起码在后辈面前要表现得成熟，我这是在较什么劲？🤔</p><p>在工作上，也算是项目的核心开发人员了吧，主要开发两个项目，项目的搭建都是我一个人完成的。自从我们组的前端离职后，我们这就没招前端了， 现在我成了真正意义的全干工程师了。不过这样也好，做前端感觉更加有成就感，可以看到自己做的项目上线，多会一门技能总归是好的。</p><h2>总结</h2><h3>代码</h3><p>2021年一共提交了109次代码，基本上是blog2.0 跟 评论系统的Go项目，相比去年来说，少了许多，一方面是工作太忙了，没办法上班写自己的项目了，公司的GitLab感觉有5 600 次提交了。两张图合到一起，好像也是每天都有写代码诶，嘿嘿</p><p>写代码也会考虑性能问题了，也想着用更简单的写法去写代码，以至于以后有人接手我的项目后，不会吐槽我的代码跟:shit:一样，自己一点一点搭建一个项目还是很有成就感的，这就是架构师的工作么？</p><p>前端因为还在学习当中，经验不足，不知道什么时候要组件化，什么时候不用，ES6的语法使用的还不够熟练，Ts也仅仅停留在会用的阶段，还不够精进，在未来的一年里，还是要努力去学习全后端的知识，成为合格的全干（栈）工程师<img src="https://cdn.ego1st.cn/postImg/2022-1.png"/><img src="https://cdn.ego1st.cn/postImg/2022-2.png"/></p><h3>健康</h3><p>健康情况，今年做了入职体检，情况还好，有些蛀牙得抽空去补了，还有就是之前一直刷牙牙龈出血，自从做了龈下洁治后，刷牙吃水果再也没出过血了，感觉很好，后悔没有早做。检查出来个小胃病也治好了。就是有一段时间加班很验证，浑身疼，肩膀疼，左右胸口疼，有一次去医院，想挂疼痛科，居然周六没有门诊，关于这点，我一直很无语，以前在家的时候，一直也没有听说看病要预约，周日没门诊，有些科室今天没有门诊的情况，难道这就是大城市嘛。</p><p>脸上的痘痘也基本治好了，泰尔丝YYDS！剩下点痘印，就让时间去消磨吧。</p><p>今年就是本命年了，妈妈给买了红裤衩跟红袜子，希望今天平平安安，灾祸退散。</p><h3>看过的</h3><p>今年看了阿B的报告，今年居然看了18000+视频，在线时间800小时，震惊，看来我还是太闲了，浪费了太多时间在B站上，再一看看的最多的视频，好家伙，居然是React全家桶跟Java教程。。还有就是一只撸狗的LOL剪辑，最喜欢的骁话一下，王骁也马上回来了，期待</p><p>今年看了45部动画，47部电影，13部电视剧，8部纪录片，4部综艺</p><p>说些印象深刻的</p><p>《家族的形式》《突如其来的假期》《东京独身男子》《国王排名》《人生一串3》</p><p>电影有个皮克斯的《心灵奇旅》和 《我是谁》都挺不错的</p><p>今年由于是番剧先审后播的制度，好像有好多好看的番剧都没赶上看</p><p>哦对，《无职转生》yyds！！！太好看啦，只可惜B站不上，叔叔拥抱生活区了，😔</p><h3>最后</h3><p>总结下吧，今年工作上涨了点工资，总之到手工资还算满意吧，如果不考虑买房的话，过着还挺滋润的，也不知道拿钱干什么，也没什么烧钱的爱好，可能今年会多花些钱在吃跟玩上，计划去一次杭州，苏州玩，来沪这么久了，居然还没到周边转转，我真是失败。如果今年过年因为疫情回不去了，那我就去南方旅游去了，可能是广州也可能是海南？到时候再看吧，希望家里的疫情早早的过去，今年郑州真是太难了，多灾多难，希望2022年一切都能好起来。</p><p>愿2022年，身体健康~ </p><p>虎年，虎虎生威，虎头虎脑，hhhhhhhhhh😁</p><p>祝家人们，朋友们，平平安安~</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020。2021，]]></title>
        <id>/2020</id>
        <link href="https://ego1st.cn/2020"/>
        <updated>2021-01-01T10:05:22.000Z</updated>
        <summary type="html"><![CDATA[2020 这个多灾多难的一年终于结束了]]></summary>
        <content type="html"><![CDATA[<div songid="1383893826"></div><p>2020 这个多灾多难的一年终于结束了</p><p>这一年，属实不易</p><p>愿明年，扭转乾坤</p><h2>🤐瞎 bb</h2><p>2020 刚开年，因为疫情在家办公（摸鱼），准备复工的时候提出了辞职。给经理打电话的时候，并没有挽留，一切都是那么的平淡。进入社会前第一次感觉到自己的渺小；尽管你在岗位上多么的努力，加再久的班，对于资本来说你就是个随时可以被换下的小螺丝。所以要努力去成为不可被替代的人！</p><p>之后就是在家浑浑噩噩的打游戏，吃喝拉撒睡。</p><p>觉得这样不行，就开始白天打游戏，深夜敲代码。没想到深夜敲代码的效率比白天高多了。</p><p>然后就是毕设答辩，本来很有信心去拿一个毕业设计，给大学四年划下一个完美的句号，事与愿违。你就是项目写的再认真，用的技术再厉害，也比不过“政治正确”的，花里胡哨的，契合老师思想的“优秀毕业设计”。就和当下比较火的“丁某”一样，引用知乎热评里的一句话“我们仇视什么，愤怒什么？是因为丁真吗？不！我们仇视的是这个稀烂的、价值扭曲的世界，我们愤怒，是因为我们收到了羞辱”</p><p>到了 7 月，准备进入职场，心里倒没什么感觉，也没有对家的留恋，也没有对爹妈的不舍。可能是从初中就开始住校，已经习惯了独来独往。倒是对朋友的依赖更多了，有天深夜跟在苏州刚工作的朋友电话，从电话里能听出他的孤独，想找个人聊天。毕竟一个人在一个城市里工作生活，难免会觉得孤独。到了上海，有两个校友一起合租，让我避免了孤独的窘境。</p><p>进入公司后，开始接触来自天南海北的同事。并不是所有的人都值得交朋友，有些仅仅是保持同事关系就够了。有些人可能在他看来是出于“好心”，但是完全不顾他人的感受的，那必然是合不来。不愿意给别人添麻烦的人，往往也不想让别人给自己添麻烦（is me）</p><p>没出校门时，以为全世界都是老二次元了，出了校门，原来就我一个二次元，想去 CP27 都没人陪。原来真的有人不看 B 站的，原来真的有人不打游戏的（:clown_face: 竟是我自己</p><p>现在的我说话也越来越谨慎，被职场磨平的棱角，高中时期那个人送外号“毒舌”的我已经不存在了。</p><p>也更加的理性了，在一些问题上考虑的也更多了，不会像高中时，脑子一热就做出决定了。不在大脑混乱的时候做决定，会冷静下来思考，可能是还没遇到那个让我神魂颠倒的人吧~</p><p>没有共情能力，在别人生气，烦恼的时候不知道该说些什么</p><p>不会聊天了，感觉跟某人聊天时已经出现了代沟，是我真的已经成为社会人，不会跟学生聊天了吗（问号脸</p><h2>:card_index_dividers:总结</h2><h3>开源项目</h3><p>2020 年提交了 304 次代码，主要是昕音乐的代码，还有博客的日常更新及依赖维护。LeetCode 是没再刷了（大意了</p><p>在进入岗位之后，学习了企业应用的开发规范，觉得之前写的代码像一坨:shit: ，遂决定重构代码，前端跟后端</p><p>前端主要重构接口，如果还有精力的话，还需要深入学习下 vue，把各个模块写成组件来重构</p><p>后端主要重构接口，将公共的资源，类提取出来，替换掉之前使用的 lombok，以及 mybatis generator，手写业务 SQL，在各个业务模块中加入缓存、日志、加上个性化配置的功能（flag）</p><p>今年还要给博客增加一个评论系统，技术栈已经想好了（Go + React）实现，应该利用业余时间，两个月差不多可以完成上线（期待吧~）</p><p><img src="https://cdn.ego1st.cn//postImg/image-20210121161631503.png" alt="image-20210121161631503"/></p><h3>健康</h3><p>到上海这边公司有食堂，最开始伙食还不错，到后面感觉饭菜不如刚来的时候，所以体重也没太大的变化，基本是在 120 斤上下浮动</p><p>今年还拔了智齿，刷 B 乎关于拔智齿的回答，有人因为拔支持伤到神经了，导致终身面瘫，舌头没有知觉。吓得我都不敢拔了。去医院，医生看了看片子，说智齿离神经比较近，可能会伤到神经，问我想好没有，当时我就吓得一哆嗦，奈何牙痛难忍，还是签了确认书。医生姐姐很专业，半小时就拔完了，当天麻药过了，也没有网上说的这么疼，我还专门买了布洛芬。睡完觉起来没什么不适，拔的很完美！感谢徐汇区牙防所的医生！</p><p>还去医院看了痘痘，医生给我开的药我都有（嘿嘿）果然久病成医啊，现在痘痘基本都消了，只剩原来手贱留下的痘印了，战痘还在继续，同志还须努力！</p><p>今年 23 了，希望自己窜一窜！身体健康！远离新冠！</p><h3>看过的</h3><p>今年看了 35 部动画，25 部电影，10 部电视剧，3 部纪录片。</p><p>由于 B 站今年没有展示出来。。我也不知道我都看了啥，应该是老番居多吧，</p><p>看的综艺，《说唱新世代》印象挺深刻的</p><p>《堀与宫村》有成为我心目中的精神食粮的潜力</p><p>电视剧的话，《校阅女孩河野悦子》《逃避可耻但有用》《刑事 ZERO》《东京大饭店》都不错！</p><p>电影印象深刻的有《绿皮书》《怦然心动》《源代码》</p><p>其中《砰然心动》里有句话：</p><p>斯人若彩虹，遇上方知有</p><p>挺好的~</p><h3>最后</h3><p>2020 年真的是发生了很多事情，有愉快的，有不愉快的，不管怎样，它都已经过去，过去的就让它过去吧，活在当下，放眼未来~</p><p>进入职场后，感觉到了生活的压力，花钱也不大手大脚了，为人处事也变得谨慎了，不再像以前那么莽撞了。</p><p>愿 2021 年，工资翻翻，身体健康~</p><p>也祝家人们，朋友们天天开心~</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019。2020，]]></title>
        <id>/2019</id>
        <link href="https://ego1st.cn/2019"/>
        <updated>2021-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2019年结束了，在这里总结一下2019年我做了些什么，以及立下2020年的Flag]]></summary>
        <content type="html"><![CDATA[<div songid="514774419"></div><p>2019年结束了，在这里总结一下2019年我做了些什么，以及立下2020年的Flag :stuck_out_tongue_closed_eyes:</p><h2>代码</h2><p><img src="https://cdn.ego1st.cn/postImg/githubcode.jpg"/></p><p><img src="https://cdn.ego1st.cn/postImg/LeetCodeNum.jpg"/></p><p><img src="https://cdn.ego1st.cn/postImg/XinMusic.jpg"/></p><p>算是后半年开始发力吧，因为就业的压力比较大，迫于提高自己的代码水平。</p><p>每天主要提交的代码是LeetCode上刷的题（目前刷到28道了）,还有昕音乐项目以及博客的提交。</p><p>在新的一年里，定下以下几个小目标:stuck_out_tongue_winking_eye:</p><ol><li>继续坚持刷题，目标100道，不求多，但是要学到其中算法的思想</li><li>昕音乐项目发布上线，并坚持维护</li><li>博客坚持写，把踩到坑，学到的东西，还有有趣的事情都记录下来</li></ol><h2>技能</h2><p>2019年7月，参加了实习，在公司里视野开阔了许多，也学到了许多新东西。在这里感谢我的导师教会了我许多东西，让我得到了非常大的提高。</p><p>:desktop_computer:买了腾讯云的服务器，并借此机会学会了Linux的使用</p><p>:robot:Docker容器化服务的简单使用</p><p>:rocket:学会了Vue以及Electron</p><p>:drooling_face:机缘巧合，学会了编写油猴脚本（其实就是写JS）</p><p>:telescope:会使用Python的selenium库进行自动化测试，顺道学会了Node.js的Puppeteer，两个东西都是自动化操作浏览器</p><p>:grinning:大学里没学会的Java多线程在一次需求开发中也掌握了</p><p>:sunglasses:写业务代码的水平自认为也提高了许多，并向着写出优雅代码的目标不断努力</p><p>:thinking:不知道算不算技能，会用IOS的快捷指令工具写一些炫酷的指令</p><p>2020年，希望自己能够掌握更多的技能，技多不压身嘛:kissing_closed_eyes:</p><ol><li>Java基础更加牢固，会用一些新特性开发</li><li>MySQL要更加熟练</li><li>Linux的操作水平达到导师80%的程度:roll_eyes:</li><li>锻炼自己看源码的能力</li><li>是时候提高独立能力了:sob:</li></ol><h2>健康</h2><p>自从参加工作以来，好像吃胖了一点，毕竟一坐坐一天:relaxed:</p><p>上次连续加班后，突然心绞痛，去医院检查了心脏和肺，都没有问题，这让我意识到了，身体是革命的本钱，一定不能连续熬夜:dizzy_face:</p><p>希望自己在2020年，健健康康，身体倍儿棒，吃嘛嘛香，再长高5厘米:stuck_out_tongue_closed_eyes:</p><h2>看过的</h2><p><img src="https://cdn.ego1st.cn/postImg/fanju.jpg"/></p><p>据不完全统计，我今年看了53部番</p><p>印象深刻的有</p><p>《刀剑神域 Alicization》</p><p>《鬼灭之刃》</p><p>《进击的巨人第三季Part2》</p><p>《辉夜大小姐想让我告白》</p><p>《多罗罗》</p><p>《卡罗尔和星期二》</p><p>《约定的梦幻岛》</p><p>《比宇宙最遥远的地方》</p><p>《吹响吧！上低音号》</p><p>《紫罗兰的永恒花园》</p><p>《冰菓》</p><p>《弦音-风舞高中弓道部》</p><p>《盾之勇者》</p><p>《强风吹拂》</p><p>还有好多.....</p><p>还有一些电视剧</p><p>《切尔诺贝利》 《爱，死亡和机器人》《轮到你了》 </p><p>电影也看了好多</p><p>最推荐的就是《天气之子》，第一遍看完，又自己跑去二刷，感触颇多，总之吹爆！！！</p><h2>最后</h2><p>2019年真的发生了许多事情，升到大四的我真是感觉压力比高三还大，值得高兴的是我找到了毕业后的工作，在上海，那里还有更多的机会还有挑战等着我。希望我能够继续保持，完成以上定下的小目标（Flag），成为一个能够独当一面的社会人:sweat_smile:~</p><p><img src="https://cdn.ego1st.cn/postImg/happynewyear2020.jpg"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gateway路由配置从数据库或Redis获取]]></title>
        <id>/GatewayRoutesFromDatabase</id>
        <link href="https://ego1st.cn/GatewayRoutesFromDatabase"/>
        <updated>2020-11-16T11:48:15.000Z</updated>
        <summary type="html"><![CDATA[目前SpringCloud Gateway只支持配置文件yml、properties和配置文件@Configuration的方式配置路由。这种方式有弊端，就是如果需要变更路由信息，修改路由规则，然后重启Gateway，修改或增加的路由规则才会生效。如果出现该问题，在Gateway重启的这段时间里，所有接入Gateway服务的应用都不可用。这肯定是不可行的。]]></summary>
        <content type="html"><![CDATA[<p>目前SpringCloud Gateway只支持配置文件yml、properties和配置文件@Configuration的方式配置路由。这种方式有弊端，就是如果需要变更路由信息，修改路由规则，然后重启Gateway，修改或增加的路由规则才会生效。如果出现该问题，在Gateway重启的这段时间里，所有接入Gateway服务的应用都不可用。这肯定是不可行的。</p><h2>Gateway默认的配置</h2><h3>yml配置文件</h3><p><img src="https://cdn.ego1st.cn//postImg/image-20201116172741310.png" alt="image-20201116172741310"/></p><h3>@Configuration</h3><p><img src="https://cdn.ego1st.cn//postImg/image-20201116172929915.png" alt="image-20201116172929915"/></p><h2>路由初始化</h2><p>不管是什么方式配置路由，这些配置最后都会被封装到<code>RouteDefinition</code>中</p><pre><code class="language-java">public class RouteDefinition {
    private String id;
    @NotEmpty
    @Valid
    private List&lt;PredicateDefinition&gt; predicates = new ArrayList&lt;&gt;();
    @Valid
    private List&lt;FilterDefinition&gt; filters = new ArrayList&lt;&gt;();
    @NotNull
    private URI uri;
    private Map&lt;String, Object&gt; metadata = new HashMap&lt;&gt;();
    private int order = 0;
    public RouteDefinition() {
    }
    ...
}
</code></pre><p>一个路由配置就是一个<code>RouteDefinition</code>对象，一个<code>RouteDefinition</code>对应一个ID，如果不设置，默认为uuid，所有路由信息在系统启动的时候被加载进内存里</p><p><img src="https://cdn.ego1st.cn//postImg/image-20201116173926638.png" alt="image-20201116173926638"/></p><p>如图框住的部分就是加载yml文件，它返回<code>PropertiesRouteDefinitionLocator</code>对象，该对象实现<code>RouteDefinitionLocator</code>接口，该接口是路由的装载器</p><pre><code class="language-java">public interface RouteDefinitionLocator {

    Flux&lt;RouteDefinition&gt; getRouteDefinitions();

}
</code></pre><p>该接口只有一个方法，就是获取路由配置，该接口有多个实现类，分别对应不同的配置路由的方式</p><p><img src="https://cdn.ego1st.cn//postImg/image-20201116174349683.png" alt="image-20201116174349683"/> </p><ol><li>CachingRouteDefinitionLocator -RouteDefinitionLocator包装类， 缓存目标RouteDefinitionLocator 为routeDefinitions提供缓存功能 </li><li>CompositeRouteDefinitionLocator -RouteDefinitionLocator包装类，组合多种 RouteDefinitionLocator 的实现，为 routeDefinitions提供统一入口</li><li>PropertiesRouteDefinitionLocator-从配置文件(GatewayProperties 例如，YML / Properties 等 ) 读取RouteDefinition </li><li>DiscoveryClientRouteDefinitionLocator-从注册中心( 例如，Eureka / Consul / Zookeeper / Etcd 等 )读取RouteDefinition</li><li>RouteDefinitionRepository-从存储器( 例如，内存 / Redis / MySQL 等 )读取RouteDefinition</li></ol><p>初始化顺序是</p><ol><li>配置文件加载初始化 PropertiesRouteDefinitionLocator--&gt;CompositeRouteDefinitionLocator </li><li>存储器中加载初始化RouteDefinitionRepository--&gt;CompositeRouteDefinitionLocator </li><li>注册中心加载初始化DiscoveryClientRouteDefinitionLocator--&gt;CompositeRouteDefinitionLocator</li></ol><p>而使用存储器中初始化的条件是，没有定义<code>RouteDefinitionRepository</code></p><pre><code class="language-java">@Bean
@ConditionalOnMissingBean(RouteDefinitionRepository.class)
public InMemoryRouteDefinitionRepository inMemoryRouteDefinitionRepository() {
    return new InMemoryRouteDefinitionRepository();
}
</code></pre><h2>路由配置从数据库中获取</h2><p>因此，我们可以通过实现<code>RouteDefinitionRepository</code>接口来自定义路由配置的获取方式</p><h3>实现RouteDefinitionRepository接口</h3><pre><code class="language-java">@Component
public class DBARouteDefinitionRepository implements RouteDefinitionRepository {

    @Resource
    private GatewayDao gatewayDao;

    @Override
    public Flux&lt;RouteDefinition&gt; getRouteDefinitions() {
        List&lt;RouteDefinition&gt; gatewayRouteEntityList = getRouteConfig();
        return Flux.fromIterable(gatewayRouteEntityList);
    }

    private List&lt;RouteDefinition&gt; getRouteConfig() {
        List&lt;RoutesEntity&gt; routesEntities = gatewayDao.queryAllRoutes();

        List&lt;RouteDefinition&gt; definitions = new ArrayList&lt;&gt;();

        //组装RouteDefinition
        for (RoutesEntity entity : routesEntities) {
            RouteDefinition definition = new RouteDefinition();

            Map&lt;String,String&gt; predicateParams = new HashMap&lt;&gt;();
            PredicateDefinition predicate = new PredicateDefinition();

            Map&lt;String,String&gt; filterParams = new HashMap&lt;&gt;();
            FilterDefinition filter = new FilterDefinition();

            URI uri = UriComponentsBuilder.fromHttpUrl(entity.getUri()).build().toUri();

            predicate.setName(&quot;Path&quot;);
            predicateParams.put(&quot;pattern&quot;,entity.getPredicates());
            predicate.setArgs(predicateParams);

            //过滤暂时不写
            //filter.setName(&quot;StripPrefix&quot;);
            //TODO 动态过滤

            definition.setPredicates(Arrays.asList(predicate));
            //definition.setFilters();

            definition.setUri(uri);
            definition.setId(entity.getRouteId());

            definitions.add(definition);
        }

        return definitions;
    }

    @Override
    public Mono&lt;Void&gt; save(Mono&lt;RouteDefinition&gt; route) {
        return null;
    }

    @Override
    public Mono&lt;Void&gt; delete(Mono&lt;String&gt; routeId) {
        return null;
    }
}
</code></pre><h3>动态路由</h3><pre><code class="language-java">@Service
public class DBARouteConfigService implements ApplicationEventPublisherAware {

    @Resource
    private GatewayDao gatewayDao;

    private ApplicationEventPublisher applicationEventPublisher;


    public int add(RoutesEntity entity){
        gatewayDao.create(entity);
        applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this));
        return 1;
    }

    public int delete(String routeId) {
        gatewayDao.deleteByRouteId(routeId);
        applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this));
        return 1;
    }

    public int update(RoutesEntity entity) {
        gatewayDao.updateRouteById(entity);
        applicationEventPublisher.publishEvent(new RefreshRoutesEvent(this));
        return 1;
    }

    /**
     * 发布事件
     * @param applicationEventPublisher
     */
    @Override
    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
        this.applicationEventPublisher = applicationEventPublisher;
    }
}
</code></pre><p>在数据库中修改删除路由配置，然后再执行一下<code>RefreshRoutesEvent</code>事件，即可刷新路由配置，无需重启，立刻生效</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud之Feign 转发请求头(header参数)]]></title>
        <id>/Feign-header</id>
        <link href="https://ego1st.cn/Feign-header"/>
        <updated>2020-08-16T11:38:54.000Z</updated>
        <summary type="html"><![CDATA[在做接口请求时，我们经常会在header头中增加一些鉴权信息，如token 或 jwt，那么在通过fegin从A server去调用B server的接口时，如果B server的接口需要header信息，我们需要将A sever获取的header转发到B上。]]></summary>
        <content type="html"><![CDATA[<p>在做接口请求时，我们经常会在header头中增加一些鉴权信息，如token 或 jwt，那么在通过fegin从A server去调用B server的接口时，如果B server的接口需要header信息，我们需要将A sever获取的header转发到B上。</p><h2>解决方式</h2><p>我们需要实现Feign提供的一个接口<code>RequestInterceptor</code></p><pre><code class="language-java">@Configuration
public class FeignConfiguration implements RequestInterceptor{
    private final Logger logger = LoggerFactory.getLogger(getClass());
            @Override
            public void apply(RequestTemplate template) {
                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder
                        .getRequestAttributes();
                HttpServletRequest request = attributes.getRequest();
                Enumeration&lt;String&gt; headerNames = request.getHeaderNames();
                if (headerNames != null) {
                    while (headerNames.hasMoreElements()) {
                        String name = headerNames.nextElement();
                        String values = request.getHeader(name);
                        template.header(name, values);
 
                    }
                    logger.info(&quot;feign interceptor header:{}&quot;,template);
                }
            }
        }
</code></pre><p>在<code>@FeignClient</code>注解里面的属性加上<code>configuration = FeignConfiguration.class</code>就可以了。如</p><pre><code class="language-java">@FeignClient(value = &quot;xinmusic-music&quot;,configuration = FeignConfig.class)
@RequestMapping(&quot;/music&quot;)
public interface MusicService {
    //todo
}
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8新特性——Optional]]></title>
        <id>/LearnJava8New3</id>
        <link href="https://ego1st.cn/LearnJava8New3"/>
        <updated>2020-07-30T15:32:50.000Z</updated>
        <summary type="html"><![CDATA[Java8 Optional]]></summary>
        <content type="html"><![CDATA[<h2>Java8 Optional</h2><p>Optional是一个包装类。类中包装的对象可以为<code>null</code>也可以为<code>非null</code>，简单来讲就是把<code>null</code>封装了一层， 防止出现空指针异常</p><h3>Optional优化null判断</h3><p>看一段代码：</p><pre><code class="language-java">public static String getAge(Student student){
    if(null == student){
        return &quot;Unkown&quot;;
    }
        return student.getAge();
}
</code></pre><p>该方法获取学生年龄，为了防止Student对象为空，做了防御性检查，我们可以使用Optional优化该段代码</p><pre><code class="language-java">public static String getAge(Student student){
    return Optional.ofNullable(student).map(Student::getAge()).orElse(&quot;Unkown&quot;);
}
</code></pre><p>可以看到，Optional结合Lambda表达式，可以让代码看起来更加优雅</p><h3>创建Optional对象</h3><pre><code class="language-java">public final class Optional&lt;T&gt; {
    
    private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();

    private final T value;

    private Optional() {
        this.value = null;
    }

    public static&lt;T&gt; Optional&lt;T&gt; empty() {
        @SuppressWarnings(&quot;unchecked&quot;)
        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;
        return t;
    }

    private Optional(T value) {
        this.value = Objects.requireNonNull(value);
    }

    public static &lt;T&gt; Optional&lt;T&gt; of(T value) {
        return new Optional&lt;&gt;(value);
    }

    public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) {
        return value == null ? empty() : of(value);
    }
    
    ...
}
</code></pre><p>可以看到Optional类的构造方法设置为了私有，所以不能通过<code>new</code>来创建，它提供了三个静态方法来创建Optional对象，<code>of(T value)</code>、<code>ofNullable(T value)</code>、<code>empty(T value)</code></p><ol><li><code>of(T value)</code>：创建一个包装值非<code>null</code>的Optional对象</li><li><code>ofNullable(T value)</code>：创建一个包装值可以为<code>null</code>的Optional对象</li><li><code>empty(T value)</code>：创建一个包装值为<code>null</code>的Optional对象</li></ol><h3>Optional类的常用方法</h3><ol><li><p><code>T get()</code>：获取Optional对象的包装值，如果包装值为<code>null</code>，则抛出<code>NoSuchElementException(&quot;No value present&quot;);</code>异常</p></li><li><p><code>boolean isPresent()</code>：判断Optional对象的包装值是否为<code>null</code></p></li><li><p><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果Optional包装值不为<code>null</code>，则执行一些动作，否则什么也不做</p></li><li><p><code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>：<code>filter</code>接受一个<code>Predicate</code>对象，可以实现对Optional对象包装值的过滤，如果满足条件则返回该Optional对象，不满足则返回空Optional对象</p></li><li><p><code>Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code>：<code>map</code>方法传入一个函数进行运算，如果Optional对象的包装值为<code>null</code>，或经过函数运算后返回值为<code>null</code>则返回一个包装值为<code>null</code>的Optional对象，否则返回经函数处理后的Optional对象，包装对象的类型可能改变</p><pre><code class="language-java">Optional&lt;Integer&gt; map = Optional.ofNullable(student).map(Student::getAge);
</code></pre></li><li><p><code>Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code>：<code>flatMap</code>方法类似于<code>map</code>方法，但是该方法可以返回一个新的Optional对象，举例如下：</p><pre><code class="language-java">Optional&lt;Integer&gt; flatmap = Optional.ofNullable(student)
                                       .flatMap(s-&gt; Optional.ofNullable(s.getAge()));
</code></pre><p>注意：<code>flatmap</code>和<code>map</code>的区别是<code>map</code>方法返回值自动封装为Optional对象，而<code>flatmap</code>方法需要手动封装为Optional对象</p></li><li><p><code>T orElse(T other)</code>：如果Optional对象包装值不为<code>null</code>则返回包装值，否则返回<code>other</code></p></li><li><p><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code>：与<code>orElse</code>的区别是将<code>Supplier</code>的<code>get</code>方法的返回值作为默认值</p></li><li><p><code>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：Optional对象包装值为<code>null</code>时，抛出异常，示例：</p><pre><code class="language-java">Optional.ofNullable(student).map(u -&gt; u.getAge()).orElseThrow(() -&gt; new RuntimeException(&quot;Unkown&quot;));
</code></pre></li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8新特性——Stream流]]></title>
        <id>/LearnJava8New2</id>
        <link href="https://ego1st.cn/LearnJava8New2"/>
        <updated>2020-06-12T13:40:55.000Z</updated>
        <summary type="html"><![CDATA[Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。]]></summary>
        <content type="html"><![CDATA[<p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><h3>什么是Stream流</h3><p>Stream 是对集合(Collection)对象功能的增强。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><p>举个简单的例子：</p><pre><code class="language-java">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);
List&lt;String&gt; filtered = strings.stream()
                               .filter(string -&gt; !string.isEmpty())
                               .collect(Collectors.toList());
</code></pre><p>上面得到的结果是把<code>strings</code>中不为空的筛选出来；</p><p>Stream对数据的处理流程如下所示：</p><pre><code class="language-java">+--------------------+       +------+   +------+   +---+   +-------+
| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|
+--------------------+       +------+   +------+   +---+   +-------+
</code></pre><h3>如何获得Stream流</h3><p>在Java8中，有三种方法生成Stream流</p><ol><li><p>通过<code>Collection</code>系列集合提供的<code>stream()</code>和<code>parallelStream()</code>方法获得流</p><p>其中通过<code>stream()</code>方法生成的是串行流，通过<code>parallelStream()</code>方法生成的是并行流</p><pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();
Stream&lt;String&gt; stream1 = list.stream();
Stream&lt;String&gt; stream2 = list.`parallelStream();
</code></pre></li><li><p>通过<code>Arrays</code>中的静态方法<code>stream()</code>获得流</p><pre><code class="language-java">Music[] music = new Music[10];
Stream&lt;Music&gt; stream3 = Arrays.stream(music);
</code></pre></li><li><p>通过Stream类中的静态方法<code>of()</code>获得流</p><pre><code class="language-java">Stream&lt;String&gt; stream4 = Stream.of(&quot;abc&quot;,&quot;a&quot;,&quot;b&quot;);
</code></pre></li></ol><p>还有两种方法创建无限流</p><ol><li><p>迭代</p><pre><code class="language-java">Stream&lt;Integer&gt; stream5 = Stream.iterate(0,(x)-&gt;x+2);
</code></pre></li><li><p>生成</p><pre><code class="language-java">Stream&lt;Double&gt; stream6 = Stream.generate(() -&gt; Math.random());
</code></pre></li></ol><p>讲完了如何获得流，下面我们来讲Stream流的中间操作</p><h3>Stream流的中间操作</h3><p>Stream流的中间操作包括：</p><ol><li>筛选与切片</li><li>映射</li><li>排序</li></ol><p>首先定义一个<code>Music</code>类</p><pre><code class="language-java">public class Music {
    private String name;
    private String singer;
    private Integer num;
    public Status status;
    
    public enum Status {
        FREE,
        BUSY
    }
    ...
    //get,set,toString,equals,hashCode,构造器省略
}
</code></pre><p>然后定义一个<code>List&lt;Music&gt;</code></p><pre><code class="language-java">List&lt;Music&gt; music = Arrays.asList(
        new Music(&quot;歌1&quot;,&quot;手1&quot;,1),
        new Music(&quot;歌2&quot;,&quot;手2&quot;,20),
        new Music(&quot;歌3&quot;,&quot;手3&quot;,30),
        new Music(&quot;歌4&quot;,&quot;手4&quot;,40),
        new Music(&quot;歌5&quot;,&quot;手5&quot;,50),
        new Music(&quot;歌6&quot;,&quot;手6&quot;,60),
        new Music(&quot;歌6&quot;,&quot;手6&quot;,70),
        new Music(&quot;歌6&quot;,&quot;手6&quot;,60)
);
</code></pre><h4>筛选与切片</h4><ol><li><p><code>filter</code>：接收Lambda，从流中排除某些元素</p><pre><code class="language-java">@Test
public void test1(){
    //内部迭代：迭代操作由Stream API完成
    music.stream()
               .filter((e)-&gt;e.getNum()&gt;10)
               .forEach(System.out::println);
}
</code></pre></li><li><p><code>limit</code>：截断流，使其元素不超过给定数量</p><pre><code class="language-java">@Test
public void test2(){
    //limit操作拿到给定数量的值后，就不再继续执行称为短路操作&quot;
    music.stream()
        .filter((e)-&gt;{
                System.out.println(&quot;短路!);
                return e.getNum()&gt;10;})
        .limit(2)
        .forEach(System.out::println);
}
</code></pre></li><li><p><code>skip</code>：跳过元素，返回一个扔掉了前n个元素的流</p><pre><code class="language-java">@Test
public void test3(){
    /// 若流中元素不足n个，则返回一个空流，与limit(n)互补
    music.stream()
            .filter((e)-&gt;e.getNum()&gt;10)
            .skip(2)
            .forEach(System.out::println);
}
</code></pre></li><li><p><code>distinct</code>筛选，通过流生成元素的hashCode()和equals()去除重复元素</p><pre><code class="language-java">@Test
public void test4(){
    music.stream()
            .filter((e)-&gt;e.getNum()&gt;10)
            .skip(2)
            .distinct()
            .forEach(System.out::println);

}
</code></pre></li></ol><h4>映射</h4><ol><li><p><code>map</code>：接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</p><pre><code class="language-java">@Test
public void test5(){
    //把list中的元素转换为大写
     List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;);
     list.stream()
             .map(s -&gt; s.toUpperCase())
             .forEach(System.out::println);
}
</code></pre></li><li><p><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流</p><pre><code class="language-java">@Test
public void test6(){
    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;);
    list.stream()
            .flatMap(StreamLearn2::filterCharater)
            .forEach(System.out::println);

}

public static Stream&lt;Character&gt; filterCharater(String str){
     List&lt;Character&gt; list = new ArrayList&lt;&gt;();

    for (Character ch :
            str.toCharArray()) {
        list.add(ch);
    }
    return list.stream();
}
</code></pre></li></ol><h4>排序</h4><ol><li><p><code>sorted</code>：自然排序（Comparable）</p><pre><code class="language-java">@Test
public void test7(){
    List&lt;String&gt; list = Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;);
    list.stream()
            .sorted()
            .forEach(System.out::println);
}
</code></pre></li><li><p><code>sorted(Comparator com)</code>：定制排序（Comparator）</p><pre><code class="language-java">@Test
public void test8(){
    music.stream()
            .sorted((e1,e2)-&gt;{
                if (e1.getName().equals(e2.getName())){
                    return e1.getNum().compareTo(e2.getNum());
                }else {
                    return e1.getName().compareTo(e2.getName());
                }
            })
            .forEach(System.out::println);
}
</code></pre></li></ol><h3>Stream流的终止操作</h3><p>Stream流的终止操作包括</p><ol><li>查找与匹配</li><li>归约</li><li>收集</li></ol><h4>查找与匹配</h4><ol><li><p><code>allMatch</code>：检查是否匹配所有元素，必须全部满足才返回<code>true</code></p><pre><code class="language-java">@Test
public void test1(){
    boolean b1 = music.stream()
            .allMatch(e-&gt;e.getStatus().equals(Music.Status.BUSY));
    System.out.println(b1);
}
</code></pre></li><li><p><code>anyMatch</code>：检查是否匹配至少一个元素，只要有一个元素满足条件就返回<code>true</code></p><pre><code class="language-java">@Test
public void test2(){
    boolean b2 = music.stream()
            .anyMatch(e-&gt;e.getStatus().equals(Music.Status.BUSY));
    System.out.println(b2);
}
</code></pre></li><li><p><code>noneMatch</code>：检查是否没有匹配所有元素，全部不满足才返回<code>true</code></p><pre><code class="language-java">@Test
public void test3(){
    boolean b3 = music.stream()
            .noneMatch(e-&gt;e.getStatus().equals(Music.Status.BUSY));
    System.out.println(b3);
}
</code></pre></li><li><p><code>findFirst</code>：返回第一个元素</p><pre><code class="language-java">@Test
public void test4(){
    Optional&lt;Music&gt; optional = music.stream()
            .sorted((e1, e2) -&gt; e1.getNum().compareTo(e2.getNum()))
            .findFirst();

    System.out.println(optional.get());
}
</code></pre></li><li><p><code>findAny</code>：返回任意一个元素</p><pre><code class="language-java">@Test
public void test5(){
    Optional&lt;Music&gt; optional = music.stream()
            .filter(e -&gt; e.getStatus().equals(Music.Status.FREE))
            .findAny();

    System.out.println(optional.get());
}
</code></pre></li><li><p><code>count</code>：返回流元素的总个数</p><pre><code class="language-java">public void test6(){
    long count = music.stream()
            .filter(e -&gt; e.getStatus().equals(Music.Status.FREE))
            .count();

    System.out.println(count);
}
</code></pre></li><li><p><code>max</code>：返回流中元素的最大值</p><pre><code class="language-java">@Test
public void test7(){
    Optional&lt;Music&gt; max = music.stream()
            .max((e1, e2) -&gt; Integer.compare(e1.getNum(), e2.getNum()));
    System.out.println(max.get());
}
</code></pre></li><li><p><code>min</code>：返回流中元素的最小值</p><pre><code class="language-java">@Test
public void test8(){
    Optional&lt;Integer&gt; min = music.stream()
            .map(Music::getNum)
            .min(Integer::compare);
    System.out.println(min.get());
}
</code></pre></li></ol><h4>归约</h4><p><code>reduce</code>：可以将流中的元素反复结合起来，得到一个值</p><ol><li><p><code> Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></p><pre><code class="language-java">Optional&lt;Integer&gt; optional = music.stream()
        .map(Music::getNum)
        .reduce(Integer::sum);
System.out.println(optional.get());
</code></pre><p>可能为<code>null</code>，返回<code>Optional</code></p></li><li><p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></p><pre><code class="language-java">Integer reduce = music.stream()
        .map(Music::getNum)
        .reduce(0, (x, y) -&gt; x + y);
</code></pre><p>起始值为0，返回对应类型</p></li><li><p><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</code></p><pre><code class="language-java">@Test
public void reduceTest() {
    ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;();

    ArrayList&lt;Integer&gt; accResult_ = Stream.of(2, 3, 4)
            .reduce(newList,
                    (acc, item) -&gt; {
                        acc.add(item);
                        System.out.println(&quot;item: &quot; + item);
                        System.out.println(&quot;acc+ : &quot; + acc);
                        System.out.println(&quot;BiFunction&quot;);
                        return acc;
                    }, (acc, item) -&gt; null);
    System.out.println(&quot;accResult_: &quot; + accResult_);
}
</code></pre><p>运行结果：</p><pre><code class="language-java">item: 2
acc+ : [2]
BiFunction
item: 3
acc+ : [2, 3]
BiFunction
item: 4
acc+ : [2, 3, 4]
BiFunction
accResult_: [2, 3, 4]
</code></pre><p>首先看一下BiFunction的三个泛型类型分别是U、 ? super T、U，参考BiFunction函数式接口apply方法定义可以知道，累加器通过类型为U和? super T的两个输入值计算得到一个U类型的结果返回。也就是说这种reduce方法，提供一个不同于Stream中数据类型的初始值，通过累加器规则迭代计算Stream中的数据，最终得到一个同初始值同类型的结果</p></li></ol><h4>收集</h4><ol><li><p><code>collect</code>：将流转化为其他形式。接受一个Collector接口的实现，用于给Stream中元素做汇总的方法</p><pre><code class="language-java">public void collectTest(){
    List&lt;String&gt; collect = music.stream()
            .map(Music::getName)
            .collect(Collectors.toList());

    HashSet&lt;String&gt; collect1 = music.stream()
            .map(Music::getName)
            .collect(Collectors.toCollection(HashSet::new));

    collect.forEach(System.out::println);
    collect1.forEach(System.out::println);
}
</code></pre><p>运行结果：</p><pre><code class="language-java">歌1
歌2
歌3
歌4
歌5
歌6
歌4
歌5
歌6
歌1
歌2
歌3
</code></pre></li><li><p><code>groupingBy</code>：分组&amp;多级分组</p><p>分组，按照相同的属性进行分组</p><pre><code class="language-java">public void groupTest1(){
    Map&lt;Music.Status, List&lt;Music&gt;&gt; collect = music.stream()
            .collect(Collectors.groupingBy(Music::getStatus));

    System.out.println(collect);
}
</code></pre><p>运行结果：</p><pre><code class="language-java">{BUSY=[Music{name=&#x27;歌1&#x27;, singer=&#x27;手1&#x27;, num=1, status=BUSY}, Music{name=&#x27;歌3&#x27;, singer=&#x27;手3&#x27;, num=30, status=BUSY}, Music{name=&#x27;歌4&#x27;, singer=&#x27;手4&#x27;, num=40, status=BUSY}], FREE=[Music{name=&#x27;歌2&#x27;, singer=&#x27;手2&#x27;, num=20, status=FREE}, Music{name=&#x27;歌5&#x27;, singer=&#x27;手5&#x27;, num=50, status=FREE}, Music{name=&#x27;歌6&#x27;, singer=&#x27;手6&#x27;, num=60, status=FREE}]}
</code></pre><p>多级分组，首先按照相同的属性分组，然后再按照条件分，或者还可以按照属性分，嵌套下去</p><pre><code class="language-java">public void groupTest2(){
    Map&lt;Music.Status, Map&lt;String, List&lt;Music&gt;&gt;&gt; collect = music.stream()
        .collect(Collectors.groupingBy(Music::getStatus, 
                Collectors.groupingBy(e -&gt; {
                    if (e.getNum() &gt;= 30) {
                        return &quot;高产&quot;;
                    } else {
                        return &quot;低产&quot;;
                    }
                })));
    System.out.println(collect);
}
</code></pre><p>运行结果：</p><pre><code class="language-java">{BUSY={低产=[Music{name=&#x27;歌1&#x27;, singer=&#x27;手1&#x27;, num=1, status=BUSY}], 高产=[Music{name=&#x27;歌3&#x27;, singer=&#x27;手3&#x27;, num=30, status=BUSY}, Music{name=&#x27;歌4&#x27;, singer=&#x27;手4&#x27;, num=40, status=BUSY}]}, FREE={低产=[Music{name=&#x27;歌2&#x27;, singer=&#x27;手2&#x27;, num=20, status=FREE}], 高产=[Music{name=&#x27;歌5&#x27;, singer=&#x27;手5&#x27;, num=50, status=FREE}, Music{name=&#x27;歌6&#x27;, singer=&#x27;手6&#x27;, num=60, status=FREE}]}}
</code></pre></li><li><p><code>partitioningBy</code>：分区，符合条件的放在一起，不符合条件的放在一起</p><pre><code class="language-java">public void partTest(){
    Map&lt;Boolean, List&lt;Music&gt;&gt; collect = music.stream()
            .collect(Collectors.partitioningBy(e -&gt; e.getNum() &gt; 30));
    System.out.println(collect);
}
</code></pre><p>运行结果：</p><pre><code class="language-java">{false=[Music{name=&#x27;歌1&#x27;, singer=&#x27;手1&#x27;, num=1, status=BUSY}, Music{name=&#x27;歌2&#x27;, singer=&#x27;手2&#x27;, num=20, status=FREE}, Music{name=&#x27;歌3&#x27;, singer=&#x27;手3&#x27;, num=30, status=BUSY}], true=[Music{name=&#x27;歌4&#x27;, singer=&#x27;手4&#x27;, num=40, status=BUSY}, Music{name=&#x27;歌5&#x27;, singer=&#x27;手5&#x27;, num=50, status=FREE}, Music{name=&#x27;歌6&#x27;, singer=&#x27;手6&#x27;, num=60, status=FREE}]}
</code></pre></li><li><p><code>join</code>连接，将结果，以什么字符开头，结尾，和分割</p><pre><code class="language-java">public void joinTest(){
    String collect = music.stream()
            .map(Music::getName)
            .collect(Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;));

    System.out.println(collect);
}
</code></pre><p>运行结果：</p><pre><code class="language-java">[歌1,歌2,歌3,歌4,歌5,歌6]
</code></pre></li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java8新特性——Lambda表达式]]></title>
        <id>/LearnJava8New1</id>
        <link href="https://ego1st.cn/LearnJava8New1"/>
        <updated>2020-05-14T16:31:20.000Z</updated>
        <summary type="html"><![CDATA[Lambda表达式]]></summary>
        <content type="html"><![CDATA[<h2>Lambda表达式</h2><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><h3>什么是Lambda？</h3><p>对于Java变量，我们可以对其进行赋值，比如：</p><pre><code class="language-java">int value = 233;
</code></pre><p>如果想把<code>一块代码</code>赋值给一个变量，在Java8之前，这个是做不到的，但是在Java8之后，我们可以使用Lambda表达式来实现，例如：</p><pre><code class="language-java">aBlockCode = (s) -&gt; System.out.println(s);
</code></pre><p>上面，把“赋值给一个<code>变量</code>的<code>函数</code>”就是<code>Lambda表达式</code></p><p>但是这里仍然有一个问题，就是变量<code>aBlockCode</code>的类型应该是什么？</p><p>下面我们来介绍函数式接口</p><h3>函数式接口</h3><p>在Java8中，所有的Lambda的类型都是一个接口，而Lambda表达式本身，就是那段函数，就是这个接口的实现，举个例子：</p><p>首先定义一个接口：</p><pre><code class="language-java">@FunctionalInterface
interface MyLambdaInterface{
    void doSomething(String s);
}
</code></pre><p>这种有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，我们称为函数式接口，可以使用<code>@FunctionalInterface</code>注解标注</p><p>我们给<code>aBlockCode</code>加上类型，我们就得到了一个完整的Lambda表达式声明，如下：</p><pre><code class="language-java">MyLambdaInterface aBlockCode = (s) -&gt; System.out.println(s);
</code></pre><h3>Lambda表达式有什么用？</h3><p>使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><p>举个例子：</p><p>我们要实现对一个数组进行筛选</p><p>首先我们定义一个函数式接口</p><pre><code class="language-java">@FunctionalInterface
public interface Predicate&lt;T&gt; {
    
    boolean filter(T t);
    
}
</code></pre><p>然后我们先使用匿名内部类的方式实现这个需求，代码如下：</p><pre><code class="language-java">//匿名内部类写法
@Test
public void test1(){
    List&lt;Integer&gt; a = Arrays.asList(1,2,3,4,5);
    List&lt;Integer&gt; b = filter(a, new Predicate&lt;Integer&gt;() {
        @Override
        public boolean filter(Integer integer) {
            return integer&gt;4;
        }
    });
    for (int c :
            b)
        System.out.println(c);
}
</code></pre><p>我们再使用Lambda表达式的方式实现这个需求，代码如下：</p><pre><code class="language-java">//Lambda表达式写法
@Test
public void test4(){
    List&lt;Integer&gt; a = Arrays.asList(1,2,3,4,5);
    List&lt;Integer&gt; b = filter(a, x -&gt; x&gt;4);
    b.forEach(System.out::println);
}
</code></pre><p>可以看出，使用Lambda表达式改写匿名内部类的实现，使代码看起来更加简洁易懂</p><p>知道了什么是Lambda还有Lambda表达式的作用，下面我们来看看Lambda表达式的基础语法</p><h3>Lambda表达式基础语法</h3><p>在Java8中，引入了一个新的操作符<code>-&gt;</code>，该操作符称为箭头操作符或者Lambda操作符</p><p>Lambda操作符把Lambda表达式拆分成了两部分</p><p>左侧：Lambda表达式的参数列表</p><p>右侧：Lambda表达式所需执行的功能，即Lambda体</p><ol><li><p>语法格式一：无参数，无返回值</p><pre><code class="language-java">() -&gt; System.out.println(&quot;Hello world&quot;);
</code></pre></li><li><p>语法格式二：有一个参数，无返回值</p><pre><code class="language-java">(s) -&gt; System.out.println(s);
s -&gt; System.out.println(s); //若只有一个参数，小括号可省略
</code></pre></li><li><p>语法格式三： 有多个参数(&gt;=2)，且Lambda体中有多条语句</p><pre><code class="language-java">Comparator&lt;Integer&gt; com = (x,y) -&gt; {
System.out.println(&quot;Lambda表达式&quot;);
return Integer.compare(x,y);
};
</code></pre></li><li><p>语法格式四：有多个参数(&gt;=2)，Lambda体中只有一条语句</p><pre><code class="language-java">Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);
</code></pre></li></ol><h3>四大核心函数式接口</h3><p>在实际开发过程中，使用Lambda表达式往往不需要自己编写函数式接口，Java已经内置了我们常用的函数式接口，使我们开发更加便捷，下面是最常用到的Java内置的函数式接口</p><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>方法</th></tr></thead><tbody><tr><td>Consumer 消费型接口</td><td>T</td><td>void</td><td>void accept(T t);</td></tr><tr><td>Supplier 供给型接口</td><td>void</td><td>T</td><td>T get();</td></tr><tr><td>Function&lt;T, R&gt; 函数型接口</td><td>T</td><td>R</td><td>R apply(T t);</td></tr><tr><td>Predicate 断言型接口</td><td>T</td><td>boolean</td><td>boolean test(T t);</td></tr></tbody></table><ol><li><p><code>Consumer&lt;T&gt;</code>消费型接口</p><pre><code class="language-java">@Test
public void test1(){
    ConsumerTest(100, x-&gt; System.out.println(x*x));
}

public void ConsumerTest(Integer a, Consumer&lt;Integer&gt; consumer){
    consumer.accept(a);
}
</code></pre></li><li><p><code>Supplier&lt;T&gt;</code>供给型接口</p><pre><code class="language-java">@Test
public void test2(){
    List&lt;Integer&gt; numList = SupplierTest(5, ()-&gt; (int)(Math.random()*100));
    numList.forEach(System.out::println);
}

public List&lt;Integer&gt; SupplierTest(Integer a, Supplier&lt;Integer&gt; supplier){
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; a ; i++) {
        Integer n = supplier.get();
        list.add(n);
    }
    return list;
}
</code></pre></li><li><p><code>Function&lt;T,R&gt;</code>函数型接口</p><pre><code class="language-java">@Test
public void test3(){
    Integer a = FunctionTest(10, x-&gt;{
        return x*200;
    });

    System.out.println(a);
}

public Integer FunctionTest(Integer a, Function&lt;Integer,Integer&gt; function){
    return function.apply(a);
}
</code></pre></li><li><p><code>Predicate&lt;T&gt;</code>断言型接口</p><pre><code class="language-java">@Test
public void test4(){
    List&lt;Integer&gt; a = Arrays.asList(1,2,3,4,5,6,7);
    List&lt;Integer&gt; res = PredicateTest(a,x-&gt;{
        return x &gt; 3;
    });

    res.forEach(System.out::println);
}

public List&lt;Integer&gt; PredicateTest(List&lt;Integer&gt; a, Predicate&lt;Integer&gt; predicate){
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

    for (Integer b :
            a) {
        if (predicate.test(b)){
            list.add(b);
        }
    }
    return list;
}
</code></pre></li></ol><h3>总结</h3><p>Lambda表达式是匿名内部类的语法糖，可以使代码更加简洁易懂，我们可以使用自定义的函数式接口或者Java内置的函数式接口来编写Lambda表达式，Lambda表达式还可以和Stream流，<code>Optional&lt;T&gt;</code>结合，使代码更加优雅。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程2]]></title>
        <id>/JavaConcurrentProgramming2</id>
        <link href="https://ego1st.cn/JavaConcurrentProgramming2"/>
        <updated>2020-01-19T18:18:30.000Z</updated>
        <summary type="html"><![CDATA[Java关于线程的相关知识，马士兵老师的高并发编程系列av11076511，知识点2]]></summary>
        <content type="html"><![CDATA[<p>Java关于线程的相关知识，马士兵老师的高并发编程系列<a href="https://www.bilibili.com/video/av11076511">av11076511</a>，知识点2</p><h1>死锁</h1><p>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h2>产生死锁的必要条件</h2><h3>1.互斥条件</h3><p>资源是独占的且排他使用。进程互斥使用资源，即任一时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一个进程占有时，则申请等待，直到该资源被占用者释放</p><h3>2.不可剥夺条件</h3><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，而只能由获得该资源的进程自愿释放</p><h3>3.请求与保持条件</h3><p>进程每次申请它所需要的一部分资源，在申请新资源的同时，继续占用已分配到的资源</p><h3>4.循环等待条件</h3><p>在发生死锁时，必然存在一个进程等待队列（P1,P2,P3....Pn），其中P1等待P2占有的资源，P2等待P1占有的资源，形成了一个进程等待环路。环路中每个进程已占有的资源同时被另一个进程所申请，即前一个进程占有后一个进程所申请的资源</p><h2>代码模拟死锁</h2><pre><code class="language-java">/*
* 线程1 先锁定对象a 3s后申请b
* 线程2 先锁定对象b 3s后申请a
* 进程无法继续推进 导致死锁问题
*/
public class T {
 
    Object a = new Object();
    Object b = new Object();
 
    public void m1() {
        synchronized (a) {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (b) {
                System.out.println(&quot;success1&quot;);
            }
        }
    }
 
    public void m2() {
        synchronized (b) {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (a) {
                System.out.println(&quot;success2&quot;);
            }
        }
    }
 
    public static void main(String[] args) {
        T t = new T();
        new Thread(t::m1, &quot;t1&quot;).start();
        new Thread(t::m2, &quot;t2&quot;).start();
    }
}

</code></pre><h1>同步方法和非同步方法是否可以同时调用？</h1><p>同步方法m1和非同步方法m2，被两个线程分别调用</p><p>问：m2方法是否需要等待m1方法执行完之后再执行</p><h3>代码如下：</h3><pre><code class="language-java">public class T {
    
    public synchronized void m1() { 
        System.out.println(Thread.currentThread().getName() + &quot; m1 start...&quot;);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; m1 end&quot;);
    }
    
    public void m2() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + &quot; m2 &quot;);
    }
    
    public static void main(String[] args) {
        T t = new T();
        new Thread(t::m1, &quot;t1&quot;).start();
        new Thread(t::m2, &quot;t2&quot;).start();
        
    }
    
}   
</code></pre><h3>结果如下：</h3><p>说明：同步方法和非同步方法可以同时调用</p><p>原因：只有被<code>synchronized</code>关键字修饰的方法在执行时才需要获得锁，没被修饰则不需要，所以m2执行并不需要先获得锁再执行</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-Day5]]></title>
        <id>/VueDay5</id>
        <link href="https://ego1st.cn/VueDay5"/>
        <updated>2019-12-01T15:09:17.000Z</updated>
        <summary type="html"><![CDATA[上个月，本来是后端程序员的我，被拉上当前端来用，第一次体验到前端的工作，还有人生中第一次加班（连着两周。。）咕咕咕好久的博客了，这次在这里总结一下噩梦18天我学到的东西，知识点可能比较杂碎~]]></summary>
        <content type="html"><![CDATA[<p>上个月，本来是后端程序员的我，被拉上当前端来用，第一次体验到前端的工作，还有人生中第一次加班（连着两周。。）咕咕咕好久的博客了，这次在这里总结一下噩梦18天我学到的东西，知识点可能比较杂碎~</p><p><img src="https://cdn.ego1st.cn/postImg/%E8%A1%A8%E6%83%851.jpg" alt="表情1"/></p><h2>Vue-Router</h2><p>Vue Router是Vue的路由管理器，以下是简单的使用步骤：</p><ol><li><p>首先要把组件映射到路由上（components---&gt;routers）：</p><pre><code class="language-js">import Vue from &#x27;vue&#x27;
import Router from &#x27;vue-router&#x27;

import Home from &#x27;./components/Home&#x27;
import Users from &#x27;./components/Users&#x27;
import MyMusic from &#x27;./components/MyMusic&#x27;

Vue.use(Router)

export default new Router({
  mode: &#x27;history&#x27;,
  base: process.env.BASE_URL,
  routes: [
    {
        path:&#x27;/&#x27;,
        component:Users
    },
    {
        path:&#x27;/home&#x27;,
        component:Home
        children:[
        {
        path:&#x27;/mymusic&#x27;,
        component:MyMusic
        }
        ]
    },
    {
        path:&#x27;*&#x27;,
        redirect:&#x27;/&#x27;
    }
  ]
})
</code></pre><p>*全匹配，即路由表中没有的，则自动跳转到“/”路径下；还可以设置<code>children</code>配置子路由，即在<code>/home</code>下跳转到<code>/chat</code>最终路由为<code>/home/chat</code></p></li><li><p>然后告诉Vue Router在哪里渲染这些组件</p><pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;
    &lt;div class=&quot;main&quot;&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre><p><code>&lt;router-view&gt;</code>标签就是渲染路由对应组件的地方</p></li></ol><p>Vue Router还可以进行动态路由匹配，举个栗子就是：我们有一个 <code>User</code> 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果</p><pre><code class="language-js">const User = {
  template: &#x27;&lt;div&gt;User&lt;/div&gt;&#x27;
}

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: &#x27;/user/:id&#x27;, component: User }
  ]
})
</code></pre><p>此时，<code>user/1</code>和<code>user/2</code>都将跳转到<code>/user</code>路由下，然后参数会被设置到<code>this.$route.params</code>中，使用方法如下：</p><pre><code class="language-js">const User = {
  template: &#x27;&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;&#x27;
}
</code></pre><h2>Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。&lt;---这是官方的解释，我的理解就是Vuex与Java中的全局变量类似。以下是Vuex的简单用法：</p><p>在<code>main.js</code>中</p><pre><code class="language-js">import Vue from &#x27;vue&#x27;
import App from &#x27;./App.vue&#x27;
import store from &#x27;./store&#x27;

Vue.config.productionTip = false

new Vue({
  store,
  render: h =&gt; h(App)
}).$mount(&#x27;#app&#x27;)
</code></pre><p>在组件中</p><pre><code class="language-vue">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    {{count}}
    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  computed: {
      count(){
        return this.$store.state.count
      },
  },
  methods: {
    increment(){
      this.$store.commit(&#x27;increment&#x27;)
    }
  }
}
&lt;/script&gt;
</code></pre><p>在Vuex的<code>store.js</code>中</p><pre><code class="language-js">import Vue from &#x27;vue&#x27;
import Vuex from &#x27;vuex&#x27;

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment(){
      this.state.count++;
    }
  },
  actions: {
  },
  modules: {
  }
})
</code></pre><p>然后在所有组件中</p><pre><code class="language-js">this.$store.state.count
</code></pre><p>即可取到<code>count</code>的值，并可使用<code>store.js</code>（Vuex的<code>mutations</code>）属性，来改变<code>count</code>的值</p><pre><code class="language-js">increment(){
      this.$store.commit(&#x27;increment&#x27;)
}
</code></pre><p>在做的项目中，仅仅简单的使用了Vuex来管理用户的基本信息，Vuex复杂的使用方式以后会专门写一篇博客来介绍（立个flag）</p><h2>axios</h2><p>axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中，类似于Jquery中的<code>$.ajax</code>。</p><p>在项目中主要用到了全局拦截和封装<code>axios</code></p><p>首先来讲全局拦截器：</p><ol><li><p>定义一个全局请求拦截器</p><pre><code class="language-js">// http request 拦截器
axios.interceptors.request.use(config =&gt; {
 //TODO
  return config;
}, err =&gt; {
    //TODO
})
</code></pre></li><li><p>定义一个全局响应拦截器</p><pre><code class="language-js">// http response 拦截器
axios.interceptors.response.use(data =&gt; {
  //TODO
  return data;
}, err =&gt; {
  //TODO
})
</code></pre></li></ol><p>然后是简单的<code>axios</code>封装</p><pre><code class="language-js">let base = &#x27;&#x27;;
export const postRequest = (url, params) =&gt; {
  return axios({
    method: &#x27;post&#x27;,
    url: `${base}${url}`,
    data: params,
    transformRequest: [function (data) {
      let ret = &#x27;&#x27;
      for (let it in data) {
        ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;
      }
      return ret
    }],
    headers: {
      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;
    }
  });
}
export const uploadFileRequest = (url, params) =&gt; {
  return axios({
    method: &#x27;post&#x27;,
    url: `${base}${url}`,
    data: params,
    headers: {
      &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27;
    }
  });
}
export const putRequest = (url, params) =&gt; {
  return axios({
    method: &#x27;put&#x27;,
    url: `${base}${url}`,
    data: params,
    transformRequest: [function (data) {
      let ret = &#x27;&#x27;
      for (let it in data) {
        ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27;
      }
      return ret
    }],
    headers: {
      &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;
    }
  });
}
export const deleteRequest = (url) =&gt; {
  return axios({
    method: &#x27;delete&#x27;,
    url: `${base}${url}`
  });
}
export const getRequest = (url) =&gt; {
  return axios({
    method: &#x27;get&#x27;,
    url: `${base}${url}`
  });
}
</code></pre><h2>杂碎的知识点</h2><ol><li><p>使用<code>setInterval()</code>方法时一定要记得销毁，利用<code>clearInterval()</code></p></li><li><p>过滤器的使用</p><pre><code class="language-js">//姓名脱敏
filters:{
    name:function(value){
        if(value == undefined) return &quot;&quot;;
        if(value.length==2) return value.substring(0,1)+&#x27;*&#x27;;
        if(value.length==3) return value.substring(0,1)+&#x27;**&#x27;;
      },
  }
</code></pre></li><li><p>vue中<code>&lt;style&gt;</code>标签的<code>scope</code>属性和深度选择器<code>/deep/</code>的使用，应用场景：你自定义一个css样式，但是又不想影响全局，这时你可以给<code>&lt;style&gt;</code>标签设置<code>scope</code>属性，这样css样式只在此组件中有效，但是有些样式又想作用在子组件中，此时可以在该样式之前加上<code>/deep</code>或者<code>::v-deep</code>，该样式就可以穿透到子组件中了。这样做不仅可以减少标签id或者class的定义还可以避免css样式污染。</p></li></ol><p>先写这么多，以后遇到新的知识点还会补充~~~</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[volatile关键字]]></title>
        <id>/volatile</id>
        <link href="https://ego1st.cn/volatile"/>
        <updated>2019-10-10T08:25:52.000Z</updated>
        <summary type="html"><![CDATA[volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。]]></summary>
        <content type="html"><![CDATA[<p><code>volatile</code>是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 <code>volatile</code> 变量，相比于<code>synchronized</code>（<code>synchronized</code>通常称为重量级锁），<code>volatile</code>更轻量级，因为它不会引起线程上下文的切换和调度。但是<code>volatile</code> 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><h2>特性</h2><p>被<code>volatile</code>关键字修饰的共享变量具有以下特性</p><ol><li>保证了不同线程对该变量操作时的内存可见性</li><li>禁止了指令重排序</li></ol><h2>理解</h2><p>A，B线程都用到了一个变量，Java默认是A运行时保存一份copy到该线程的缓存中，此时如果B线程修改了该变量，则线程A未必知道，因为A线程用的是自己缓存中的该变量的拷贝</p><p>使用<code>volatile</code>关键字修饰，会让所有线程读到该变量的修改值，强制线程读取堆内存</p><pre><code class="language-java">public class T {
    //对比一下有无volatile的情况下，整个程序运行结果的区别
    /*volatile*/ boolean running = true; 
    void m() {
        System.out.println(&quot;m start&quot;);
        while(running) {
            /*
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {          
                e.printStackTrace();
            }*/
        }
        System.out.println(&quot;m end!&quot;);
    }
    
    public static void main(String[] args) {
        T t = new T();
        
        new Thread(t::m, &quot;t1&quot;).start();
        
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        t.running = false;
    }
}
</code></pre><p>运行以上代码可以发现，当running变量没有被<code>volatile</code>关键字修饰时，线程t1一直运行；当running变量被<code>volatile</code>关键字修饰时，主线程改变running值，t1线程会读取到改变进而输出“m end”结束线程</p><p>以上的说法方便理解</p><p>其实真实的情况是，没有被<code>volatile</code>关键字修饰的变量，t1线程使用时会拷贝一份到该线程的缓存中，但是，当CPU空闲时，仍然会去堆内存中读取running值，从而导致t1线程停止。</p><h2>volatile关键字注意点</h2><ol><li><p><code>volatile</code>关键字并不能保证多个线程共同修改同一个变量所带来的不一致问题，也就是说<code>volatile</code>不能替代<code>synchronized</code>关键字解决同步问题</p><pre><code class="language-java">public class T {
    volatile int count = 0; 
    void m() {
        for(int i=0; i&lt;10000; i++) count++;
    }
    public static void main(String[] args) {
        T t = new T();
        List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(); 
        for(int i=0; i&lt;10; i++) {
            threads.add(new Thread(t::m, &quot;thread-&quot;+i));
        }
        threads.forEach((o)-&gt;o.start());
        threads.forEach((o)-&gt;{
            try {
                o.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(t.count);    
    }   
}
</code></pre><p>输出：</p><pre><code class="language-java">55600
</code></pre><p>这说明<code>volatile</code>关键字并不能解决同步问题，因为每个线程可能从内存中读取到的值一样，并在此基础上相加，所以输出的值远远小于10000</p></li><li><p><code>synchronized</code>关键字保证可见性和原子性，<code>volatile</code>关键字只能保证可见性</p></li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[synchronized关键字]]></title>
        <id>/concurrent</id>
        <link href="https://ego1st.cn/concurrent"/>
        <updated>2019-10-08T10:18:47.000Z</updated>
        <summary type="html"><![CDATA[synchronized关键字的意义]]></summary>
        <content type="html"><![CDATA[<h2><code>synchronized</code>关键字的意义</h2><p>为了防止代码块受并发访问的干扰，Java语言提供一个 synchronized关键字达 到这一目的，并且 Java SE 5.0引入了 ReentrantLock 类。synchronized 关键字自动提供一个 锁以及相关的“ 条件”， 对于大多数需要显式锁的情况， 这是很便利的。</p><h2><code>synchronized</code>关键字的作用</h2><p>synchronized关键字是对某个对象加锁</p><p>举个例子，如以下代码段：</p><pre><code class="language-java">private Object o = new Object();
public void m() {
    synchronized(o) { //任何线程要执行下面的代码，必须先拿到o的锁
        count--;
        System.out.println(Thread.currentThread().getName() + &quot; count = &quot; + count);
        }
}
</code></pre><p>还有另一种用法</p><pre><code class="language-java">public void m() {   
    synchronized(this) { //任何线程要执行下面的代码，必须先拿到this的锁      
        count--;                
        System.out.println(Thread.currentThread().getName() + &quot; count = &quot; + count);   
    }
}
</code></pre><p>这种方式等同于如下代码段：</p><pre><code class="language-java">public synchronized void m() { //等同于在方法的代码执行时要synchronized(this)   
    count--;   
    System.out.println(Thread.currentThread().getName() + &quot; count = &quot; + count);
}
</code></pre><p><strong>注意</strong>：当<code>synchronized</code>关键字修饰方法时，锁定的是this，也就是该对象本身；当<code>synchronized</code>关键字修饰的是静态方法或者静态变量时，锁定的是<code>对象.class</code></p><h2><code>synchronized</code>关键字的注意点</h2><ol><li><p>同步方法和非同步方法可以同时调用，原因是调用非同步方法时不需要拿到锁</p></li><li><p>在应用场景中，对写方法（set）加锁，对读方法（get）不加锁，容易产生脏读问题，原因是，在①线程写入操作还没有完成时，此时②线程读取数据，此时读到的数据不是实际写入的数据</p></li><li><p>一个同步方法可以调用另一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候，仍然会得到该对象的锁，也就是说<code>synchronized</code>获得的锁是可重入的</p></li><li><p>可重入锁的实现机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。</p></li><li><p>子类可以调用父类的同步方法，锁住的是子类对象</p></li><li><p>在同步方法执行的过程中，如果出现异常，默认情况下锁会被释放，若不想被释放，则需要<code>catch</code>异常</p></li><li><p>同步代码块中的语句越少越好，采用细粒度的锁，可以使线程争用的时间变短，从而提高效率</p></li><li><p>锁定的某个对象o，如果o的属性发生改变，不影响锁的使用，但是如果o变成另一个对象，则锁定的对象发生改变，如以下代码：</p><pre><code class="language-java">public class T {
    Object o = new Object();
    void m() {
        synchronized(o) {
            while(true) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName());
            }
        }
    }
    public static void main(String[] args) {
        T t = new T();
        //启动第一个线程
        new Thread(t::m, &quot;t1&quot;).start();
        
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //创建第二个线程
        Thread t2 = new Thread(t::m, &quot;t2&quot;);
        //锁对象发生改变，所以t2线程得以执行，如果注释掉这句话，线程2将永远得不到执行机会
        t.o = new Object(); 
        t2.start();
        
    }
}

输出：
t1
t1
t1
t2
t1
t2
t1
t2
t1
t2
t1

Process finished with exit code -1
</code></pre></li><li><p>不要用字符串常量作为锁定对象，如下：</p><pre><code class="language-java">public class T {
    String s1 = &quot;Hello&quot;;
    String s2 = &quot;Hello&quot;;
    void m1() {
        synchronized(s1) {
            
        }
    }
    void m2() {
        synchronized(s2) {
            
        }
    }
}
</code></pre><p>m1和m2其实锁定的是同一个对象；此时有可能发生诡异的现象，比如你用到的一个类库，在该类库中代码中也锁定了字符串“Hello”，这时就有可能发生死锁阻塞，因为你的程序和你用到的类库在不经意间使用了同一把锁</p></li></ol><h2><code>synchronized</code>的原理</h2><h3>同步代码块</h3><p><img src="https://cdn.ego1st.cn/postImg/synchronized1.png"/></p><p><strong>monitorenter ：</strong></p><p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p><p><strong>monitorexit：</strong></p><p>　　执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p><p>​		指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p><p>　　Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><h3>同步方法</h3><p><img src="https://cdn.ego1st.cn/postImg/synchronized2.png"/></p><p>从反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/huangyin/p/6586469.html">https://www.cnblogs.com/huangyin/p/6586469.html</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java并发编程1]]></title>
        <id>/JavaConcurrentProgramming</id>
        <link href="https://ego1st.cn/JavaConcurrentProgramming"/>
        <updated>2019-09-30T14:29:55.000Z</updated>
        <summary type="html"><![CDATA[最近在看Java关于线程的相关知识，看的是马士兵老师的高并发编程系列av11076511，遂把知识点整理下来，便于以后查阅。]]></summary>
        <content type="html"><![CDATA[<p>最近在看Java关于线程的相关知识，看的是马士兵老师的高并发编程系列<a href="https://www.bilibili.com/video/av11076511">av11076511</a>，遂把知识点整理下来，便于以后查阅。</p><h2>线程的创建</h2><h3>通过继承<code>Thread</code>类并重写<code>run()</code>方法</h3><p>通过继承<code>Thread</code>类并重写<code>run()</code>方法，<code>run()</code>方法中定义需要线程执行的任务，然后调用实现类的<code>start()</code>方法启动这个线程（ps：单纯的调用<code>run()</code>方法只是单纯的方法使用，并不能达到启动线程的目的）</p><pre><code class="language-java">public class Current extends Thread {
    public void run() {
        System.out.println(&quot;子线程启动,ID为:&quot; + Thread.currentThread().getId() +
                &quot;,名字为&quot; + Thread.currentThread().getName());
    }

        public static void main(String[] args)  {
            // 创建一个线程并开启线程
            Current a = new Current();
            a.start();
            // 多创建几个线程
            new Current().start();
            new Current().start();
            new Current().start();

        }
}
</code></pre><p>输出如下：</p><pre><code class="language-java">子线程启动,ID为:14,名字为Thread-2
子线程启动,ID为:12,名字为Thread-0
子线程启动,ID为:13,名字为Thread-1
子线程启动,ID为:15,名字为Thread-3
</code></pre><h3>通过继承<code>Runnable</code>接口，并实现<code>run()</code>方法</h3><p>通过继承<code>Runnable</code>接口，实现<code>run()</code>方法，然后调用实现类的<code>start（）</code>方法启动这个线程</p><pre><code class="language-java">public class WithRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;子线程启动,ID为:&quot; + Thread.currentThread().getId() +
                &quot;,名字为&quot; + Thread.currentThread().getName());
    }

    public static void main(String[] args)  {
        // 创建一个线程并开启线程
        Current a = new Current();
        a.start();
        // 多创建几个线程
        new Current().start();
        new Current().start();
        new Current().start();

    }
}
</code></pre><p>输出如下：</p><pre><code class="language-java">子线程启动,ID为:13,名字为Thread-1
子线程启动,ID为:15,名字为Thread-3
子线程启动,ID为:12,名字为Thread-0
子线程启动,ID为:14,名字为Thread-2
</code></pre><h2>线程的五种状态</h2><p>线程有五个状态</p><ol><li>新生（<code>new</code>）：用<code>new</code>关键字新建了一个线程对象后，该线程对象处于新生态，此时已经有了自己的内存空间</li><li>就绪（<code>runnable</code>）：调用了<code>start（）</code>方法后，线程从新生态转化为就绪态，此时线程还没有运行，在等待CPU调度</li><li>运行（<code>running</code>）：处于运行状态的线程正在执行自己的<code>run()</code>方法</li><li>阻塞<code>(blocked)</code>：线程暂停执行，让出CPU时间片，并将其交给其他线程使用</li><li>死亡<code>dead</code>：当前线程完成工作或者抛出异常时，线程死亡</li></ol><p><img src="https://cdn.ego1st.cn/postImg/xiancheng.png" alt="线程的状态"/></p><p>以上简单的介绍了一下线程的基础，下面是关于线程的同步问题</p><h2>线程同步</h2><p>在大多数实际的多线程应用中， 两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象， 并且每一个线程都调用了一个修改该对象状态的方法，将会发 生什么呢？ 可以想象，线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生i化 误的对象。这样一个情况通常称为竞争条件（race condition)。为了避免多线程引起的对共享数据的说误，必须学习如何同步存取。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSH]]></title>
        <id>/SSH</id>
        <link href="https://ego1st.cn/SSH"/>
        <updated>2019-09-27T15:54:12.000Z</updated>
        <summary type="html"><![CDATA[最后一次！！！！！！！]]></summary>
        <content type="html"><![CDATA[<h2>最后一次！！！！！！！</h2><p>测试TravisCI通过SSH登陆服务器，完成部署博客的任务</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode4--FindMedianSortedArrays]]></title>
        <id>/LeetCode4-FindMedianSortedArrays</id>
        <link href="https://ego1st.cn/LeetCode4-FindMedianSortedArrays"/>
        <updated>2019-09-14T12:45:11.000Z</updated>
        <summary type="html"><![CDATA[题目描述]]></summary>
        <content type="html"><![CDATA[<h2>题目描述</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><p>nums1 = <!-- -->[1, 3]<!-- -->
nums2 = <!-- -->[2]</p><p>则中位数是 2.0
示例 2:</p><p>nums1 = <!-- -->[1, 2]<!-- -->
nums2 = <!-- -->[3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p><h2>思路</h2><h3>第一种（暴力解法）</h3><p>两个有序数组，我想到了归并排序中的第二步。合并两个有序数组，然后求出中位数</p><h4>代码</h4><pre><code class="language-java">public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int m = nums1.length;
        int n = nums2.length;
        int[] nums = new int[m+n];

        if (m == 0) {
            return n % 2 == 0?(nums2[n / 2 - 1] + nums2[n / 2]) / 2.0 : nums2[n / 2];
        }
        if (n == 0) {
            return m % 2 == 0?(nums1[m / 2 - 1] + nums1[m / 2]) / 2.0 : nums1[m / 2];
        }

        int count = 0;
        int i = 0, j = 0;
        while (count != (m + n)) {
            if (i == m) {
                //--------------------------------------------------------
                //当有一个数组遍历完之后，另一个数组直接灌入新的数组 跳过判断
                while (j != n) {
                    nums[count++] = nums2[j++];
                }
                break;
            }
            if (j == n) {
                while (i != m) {
                    nums[count++] = nums1[i++];
                }
                break;
                //---------------------------------------------------------
            }
            //-------------------------------------------------------------
            //比大小，小的数填入新的数组，下标右移
            if (nums1[i] &lt; nums2[j]) {
                nums[count++] = nums1[i++];
            } else {
                nums[count++] = nums2[j++];
            }
        }
            //--------------------------------------------------------------
        if (count % 2 == 0) {
            return (nums[count / 2 - 1] + nums[count / 2]) / 2.0;
        } else {
            return nums[count / 2];
        }

    }
</code></pre><p>时间复杂度：<code>O（m+n）</code></p><h3>第二种（寻找第n小的数）</h3><p>中位数的定义：是按顺序排列的一组数据中居于中间位置的数。</p><p>所以我们只需要寻找一个有序数组中第n/2位置的数就可以了。（n为两个数组的长度之和）</p><p>寻找第n/2小的数，找的思路如下图所示</p><p><img src="https://cdn.ego1st.cn/postImg/findSmall.gif"/></p><h4>代码</h4><pre><code class="language-java">public double findMedianSortArrays(int[] nums1, int[] nums2){
        int m = nums1.length;
        int n = nums2.length;
        int left = (m+n+1)/2;
        int right = (m+n+2)/2;
        //当数组的长度为奇数时，求出两个相同的数除以2为中位数，偶数则是left，right位置的数相加除以2
        return (getKth(nums1,0,m-1,nums2,0,n-1,left)+getKth(nums1,0,m-1,nums2,0,n-1,right))*0.5;
    }
    //递归调用
    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让len1永远比len2小，遇到大小相同的数时，留上面的，排除下面的
        if (len1 &gt; len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);
        //一个数组被排除到空，返回另一个数组的当前第K值
        if (len1 == 0) return nums2[start2 + k - 1];
        //如果k=1 返回两个数组中 第一个数字小的那个数，就是我们要找的第K小的数
        if (k == 1)return Math.min(nums1[start1],nums2[start2]);
        //如果k/2 比 当前数组长度长，则直接取 数组长度
        int i = start1 + Math.min(len1, k/2)-1;
        int j = start2 + Math.min(len2, k/2)-1;

        //排除小的数
        if (nums1[i] &gt; nums2[j]){
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
        else{
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        }


    }
</code></pre><p>时间复杂度：<code>O(log(m+n）</code></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-Day4]]></title>
        <id>/VueDay4</id>
        <link href="https://ego1st.cn/VueDay4"/>
        <updated>2019-09-04T07:53:17.000Z</updated>
        <summary type="html"><![CDATA[Vue生命周期]]></summary>
        <content type="html"><![CDATA[<h2>Vue生命周期</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。（摘自<a href="https://cn.vuejs.org/%EF%BC%89">https://cn.vuejs.org/）</a></p><h2>实例的生命周期图</h2><p><img src="https://cdn.ego1st.cn/postImg/vuelife.png"/></p><h2>生命周期钩子在<code>new Vue</code>内以<strong>属性</strong>的方式进行声明</h2><pre><code class="language-html">new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log(&#x27;a is: &#x27; + this.a)
  }
})
</code></pre><p>注：在生命周期函数中不能使用箭头函数（=&gt;）</p><h2>生命周期函数</h2><ol><li><code>beforeCreate</code>在实例初始化之后，数据观测（<code>data observer</code>）和 <code>event/watcher事件</code>配置之前被调用,简单来是，就是页面加载之前被调用，一般可以在这里加载动画</li><li><code>created</code>在实例创建之后被调用，这一步已经完成了数据观测（<code>data observer</code>），属性和方法的运算，<code>watch/event</code>事件回调，但是<strong>挂载</strong>还没有开始，<code>$el</code>属性目前不可见。一般可以在这里获取数据</li></ol><hr/><ol start="3"><li><p>接下来<code>Vue</code>会判断是否有<code>el</code>属性，</p><ul><li><p>如果有，则检查有没有<code>template</code></p></li><li><p>如果没有，则检查有没有<code>.$mount</code>，如果没有，则整个生命周期结束</p></li></ul></li><li><p>有<code>template</code>，则执行<code>template</code>中具体的组件，<code>render</code>方法渲染页面，或者具体标签</p></li><li><p>没有<code>template</code>和<code>.$mount</code>，则生命周期结束</p></li></ol><hr/><ol start="6"><li><code>beforeMount</code>在挂载之前被调用，相关的渲染函数首次被调用，虚拟Dom已经配置，但是页面仍未显示</li><li><code>mounted</code>组件挂在后，<code>el</code>被新创建的<code>vm.$el</code>替换，挂载成功，此方法执行后，页面显示</li><li><code>beforeUpdate</code>组件更新前，页面仍未更新，但虚拟Dom已经配置</li><li><code>updated</code>组件更新，此方法执行后，页面显示</li><li><code>beforeDestroy</code>组件销毁前</li><li><code>destoryed</code>组件销毁</li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-Day3]]></title>
        <id>/VueDay3</id>
        <link href="https://ego1st.cn/VueDay3"/>
        <updated>2019-09-02T07:38:12.000Z</updated>
        <summary type="html"><![CDATA[Vue笔记 Day3]]></summary>
        <content type="html"><![CDATA[<h2>Vue笔记 Day3</h2><h2>Vue中使用样式-css</h2><p>假设<code>&lt;style&gt;</code>标签中有样式，如下</p><pre><code class="language-html">&lt;style&gt;
        .red{
            color: red;
        }
        .thin{
            font-weight: 200;
        }
        .italic{
            font-style: italic;
        }
        .active{
            letter-spacing: 0.5em;
        }
    &lt;/style&gt;
</code></pre><h3>第一种方式</h3><p><strong>直接传递一个数组， 注意：这里的class需要使用 v-blind做数组绑定</strong></p><pre><code class="language-html"> &lt;h1 :class=&quot;[&#x27;thin&#x27;, &#x27;italic&#x27;]&quot;&gt;it&#x27;s a Huge H1&lt;/h1&gt; 
</code></pre><p><strong>还可以在数组中使用三元表达式，如</strong></p><pre><code class="language-html">&lt;h1 :class=&quot;[&#x27;thin&#x27;, &#x27;italic&#x27;, flag?&#x27;active&#x27;:&#x27;&#x27;]&quot;&gt;it&#x27;s a Huge h1&lt;/h1&gt; 
&lt;!--flag为data中定义的数据--&gt;
</code></pre><p><strong>在数组中可以用对象替换三元表达式</strong></p><pre><code class="language-html">&lt;h1 :class=&quot;[&#x27;thin&#x27;, &#x27;italic&#x27;, {&#x27;active&#x27;:flag }]&quot;&gt;it&#x27;s a Huge h1&lt;/h1&gt;
</code></pre><p><strong>直接使用对象</strong></p><pre><code class="language-html">&lt;!--v-bind绑定class的时候，对象的属性是类名，由于对象的属性可带引号，也可以不带引号,属性的值是一个标识符--&gt;
&lt;h1 :class=&quot;{red:true, thin:true, italic:false, active:false}&quot;&gt;it&#x27;s a Huge h1&lt;/h1&gt;
</code></pre><h3>第二种方式</h3><p><strong>在<code>style</code>中书写</strong></p><pre><code class="language-html"> &lt;h1 :style=&quot;{color:&#x27;red&#x27;, &#x27;font-weight&#x27;: 200 }&quot;&gt;This is a h1&lt;/h1&gt;
</code></pre><p><strong>定义在<code>data</code>中</strong></p><pre><code class="language-html">&lt;h1 :style=&quot;styleObj1&quot;&gt;This is a h1&lt;/h1&gt;
</code></pre><p><strong>用数组的形式，将<code>style</code>放入其中</strong></p><pre><code class="language-html">&lt;h1 :style=&quot;[styleObj1, styleObj2]&quot;&gt;This is a h1&lt;/h1&gt;
</code></pre><pre><code class="language-javascript">new Vue(
  {
   el:&#x27;#app&#x27;,
   data:{
   styleObj1:{
   color: &#x27;red&#x27;,
   &#x27;font-weight&#x27;: 200
   },
     styleObj2:{
     &#x27;font-style&#x27;: &#x27;italic&#x27;,
      }
   }
</code></pre><h2>v-for循环</h2><p>假设有数组，对象数组，对象如下：</p><pre><code class="language-javascript">new Vue({
    el: &#x27;#app&#x27;,
    data: {
    list1:[1,2,3,4,5,6],

     list2:[
           {id:1, name:&#x27;a&#x27;},
            {id:2, name:&#x27;b&#x27;},
            {id:3, name:&#x27;c&#x27;},
            {id:4, name:&#x27;d&#x27;},
            ],
      user:{
            id:1,
            name: &#x27;Jack&#x27;,
            gender: &#x27;male&#x27;,
            }
     }
</code></pre><h3>v-for循环数组</h3><pre><code class="language-html">&lt;!--item为每一项的值，i为每一项的下标--&gt;
&lt;p v-for=&quot;(item, i) in list1&quot;&gt;{{item}}------index:{{i}}&lt;/p&gt;
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-09-02_08-18-08.jpg"/></p><h3>v-for循环对象数组</h3><pre><code class="language-html">&lt;p v-for=&quot;usr in list2&quot;&gt;{{ usr.id }}------name:{{ usr.name }}&lt;/p&gt;
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-09-02_08-21-45.jpg"/></p><h3>v-for循环对象</h3><pre><code class="language-html">&lt;p v-for=&quot;(val, key, index) in user&quot;&gt;value:{{val}}---key:{{key}}--index:{{index}}&lt;/p&gt;
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-09-02_08-25-53.jpg"/></p><h3>v-for迭代数字</h3><pre><code class="language-html">&lt;p v-for=&quot;count in 10&quot;&gt;loop{{count}}&lt;/p&gt;
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-09-02_09-06-44.jpg"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot配置热部署]]></title>
        <id>/SpringBootHotDeploy</id>
        <link href="https://ego1st.cn/SpringBootHotDeploy"/>
        <updated>2019-08-27T13:06:24.000Z</updated>
        <summary type="html"><![CDATA[spring为开发者提供了一个名为spring-boot-devtools的模块来使Spring Boot应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用。下面我们在IDEA中配置SpringBoot热部署。]]></summary>
        <content type="html"><![CDATA[<p>spring为开发者提供了一个名为spring-boot-devtools的模块来使Spring Boot应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用。<!-- -->下面我们在IDEA中配置SpringBoot热部署。</p><h2>添加pom.xml依赖</h2><pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre><h2>修改IDEA设置</h2><ol><li>File--&gt;Settings--&gt;Build,Execution,Depliyment--&gt;Compiler--&gt;Build Project automatically--&gt;打上√</li><li><code>Ctrl+Shift+Alt+/</code>组合键--&gt;选择registry--&gt;找到<code>Compiler autoMake allow when app running</code>打上 √</li></ol><h2>完成</h2><p>这时候启动项目 然后修改代码就能实现热部署了</p><h2>原理</h2><p>深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[持续化部署你的blog]]></title>
        <id>/TravisCIYourBlog</id>
        <link href="https://ego1st.cn/TravisCIYourBlog"/>
        <updated>2019-08-13T15:36:06.000Z</updated>
        <summary type="html"><![CDATA[上一周把自己的博客搬到新买的腾讯云上了，为了节省部署的时间，所以我的博客使用了持续化部署，其中踩了许多坑，写个教程总结记录一下。]]></summary>
        <content type="html"><![CDATA[<p>上一周把自己的博客搬到新买的腾讯云上了，为了节省部署的时间，所以我的博客使用了持续化部署，其中踩了许多坑，写个教程总结记录一下。  </p><p>大概的过程：</p><ol><li><p>首先在你的服务器上安装Git，搭建Git服务器，并使用免密登陆SSH</p></li><li><p>在服务器上创建仓库用来存放TravisCI生成的博客静态文件</p></li><li><p>把你的博客项目放在GitHub上，其中博客静态文件放在主分支（master）上，其他文件（博客项目）放在其他分支上（本文为hexo分支）</p></li><li><p>配置TravisCI，监听你的hexo分支，即你写完博客，push到GitHub上，TravisCI监听到hexo分支发生改变，自动帮你构建博客静态文件</p></li><li><p>TravisCI帮你构建完静态文件后，通过git命令把博客静态文件push到博客仓库主分支上和你的服务器Git仓库中</p></li><li><p>配置服务器Git仓库钩子（GitHooks），使服务器仓库发现有push到仓库的动作后，自动把仓库中的静态文件部署到网站根目录</p></li></ol><h2>在VPS上搭建Git服务端</h2><p>默认使用的操作系统为Centos7  </p><h3>安装Git服务</h3><p>首先查看yum源仓库的Git信息</p><pre><code class="language-shell">$ yum info git
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-14_16-33-13.jpg"/></p><p>版本是1.8.3.1，想使用最新版的Git，只能使用编译安装  </p><h4>下载Git：</h4><p>Git<a href="https://pan.baidu.com/s/1HEz1isggSfyDXnfrITBSTA" title="With a Title">下载地址</a>. 提取码: ugu2</p><h4>在Centos7中安装依赖库</h4><pre><code class="language-shell">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel
$ yum install gcc perl-ExtUtils-MakeMaker
</code></pre><h4>卸载低版本Git</h4><pre><code class="language-shell">yum remove git
</code></pre><h4>解压编译安装Git</h4><p>移动到存放Git源码的目录，我的在<code>/usr/local/git </code>git目录自己创建  </p><p>解压编译安装</p><pre><code class="language-shell">$ tar -xzvf git-2.22.0.tar.gz
$ cd git-2.22.0
$ make prefix=/usr/local/git all
$ make prefix=/usr/local/git install
</code></pre><p>添加到环境变量</p><pre><code class="language-shell">$ vim /etc/profile
#在末尾添加
$ export PATH=&quot;/usr/local/git/bin:$PATH&quot;
</code></pre><p>保存退出，使配置立即生效</p><pre><code class="language-shell">$ source /etc/profile
$ git --version  #查看版本号
</code></pre><p>将git设置为默认路径</p><pre><code class="language-shell">$ ln -s /usr/local/git/bin/git-upload-pack /usr/bin/git-upload-pack 
$ ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack 
</code></pre><p>创建一个git用户组和用户，用来运行git服务</p><pre><code class="language-shell">$ groupadd git
$ useradd git -g git
$ passwd git #参数是用户名
$ su git  #切换git用户
</code></pre><h3>在服务器上搭建Git仓库</h3><h4>创建仓库目录</h4><p>我的仓库目录在<code>/srv/gitrepo</code></p><pre><code class="language-shell">$ cd /srv/gitrepo # gitrepo目录自己创建
$ git init blog.git --bare # 创建仓库目录
</code></pre><p>至此，一个服务器Git仓库就搭建好了，还没实现免密登陆，后面会讲到</p><h2>使用TravisCI持续化部署</h2><h3>配置TravisCI</h3><h4>使用Github账号登陆TravisCI</h4><p><a href="https://travis-ci.org">TravisCi</a>,注意网站地址结尾是org（公开的），com结尾的是私有的，是收费的</p><h4>添加你的仓库</h4><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-14_17-19-07.jpg"/></p><h4>配置你的仓库</h4><p>点击<code>Setting</code> ，设置选项
<img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-14_17-22-28.jpg"/></p><h4>在Github添加Access Token</h4><p><code>Setting</code>--&gt;<code>Developer setting</code>--&gt;<code>Personal access tokens</code>--&gt;<code>Generate new token</code>
<img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-14_17-27-04.jpg"/>除了删库，其他的都打上勾</p><h4>在TravisCI设置中添加token</h4><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-14_17-31-40.jpg"/></p><p><code>name</code>自定义 ，<code>value</code>为Github上的<code>access Token</code>点击Add添加 </p><h4>在你的本地博客目录下添加<code>.travis.yml</code></h4><p>具体配置如下</p><pre><code class="language-yaml">language: node_js
node_js: lts/*
install:
- npm install
before_script:
script:
- hexo clean
- hexo g
after_script:
- cd ./public
- git init
- git config user.name &quot;&quot; # 你的Git名字
- git config user.email &quot;&quot; # 你的Git邮箱
- git add .
- git commit -m &quot;Update docs with TRAVIS-CI&quot; # conmmit信息
- git push --force --quiet &quot;https://${myblog}@${GH_REF}&quot; master:master

branches:
  only:
  - hexo # 监听hexo分支变化，具体把源文件提交到分支，请左转度娘
env:
  global:
  - GH_REF: github.com/EGo14T/ego14t.github.io.git
cache:
  yarn: true
  directories:
  - node_modules
before_install:
after_success:
addons:
  ssh_known_hosts: # 给Travis服务器添加你的VPS ip地址，以跳过询问
</code></pre><p>到这一步你已经可以自动部署你的博客到Github Pages了</p><h3>Travis免密登陆你的VPS</h3><h4>生成SSH密钥对</h4><pre><code class="language-shell"># 随便生成在哪都行，文件名也随意
$ ssh-keygen -f travis.key
</code></pre><p>把生成的公钥文件<code>e.g. travis.key.pub</code> 内容添加到VPS上的<code>~/.ssh/authorized_keys</code>中</p><pre><code class="language-shell">$ vi ~/.ssh/authorized_keys #把公钥添加进去
</code></pre><h4>使用Travis CI 加密工具加密私钥</h4><p>这个步骤必须在Linux下执行！！！</p><p>这个步骤必须在Linux下执行！！！</p><p>这个步骤必须在Linux下执行！！！ 重要的事情说三遍</p><h5>安装加密工具</h5><p>首先你要安装Ruby，具体安装，自己百度</p><pre><code class="language-shell">#安装加密工具
$ sudo gem install travis   
</code></pre><h5>通过命令行登录 Travis 并加密文件：</h5><pre><code class="language-shell"># 交互式操作，使用 GitHub 账号密码登录
$ travis login --auto
# 加密完成后会在当前目录下生成一个 travis.key.enc 文件
# 会在你的 .travis.yml 文件里自动加上用于解密的 shell 语句
# 会自动格式化你的 .travis.yml 文件
$ travis encrypt-file travis.key -add
</code></pre><p>以上步骤建议在你的博客项目根目录进行</p><p>把你的博客项目push到刚才创建的VPS Git仓库中</p><p>为了能免密登陆自己的VPS服务器，把刚才的私钥也拷贝一份放到<code>C:\Users\用户名\.ssh</code>目录下，然后push项目</p><p>然后在本地把加密操作后的项目从VPS Git仓库中clone下来</p><h3>使用GitHooks自动部署你的静态文件</h3><p>首先要在<code>.travis.yml</code>文件中追加push到你的VPS Git仓库的命令</p><p>通过SSH的方式push</p><h4>配置GitHooks</h4><p>在你的VPS Git仓库中找到hooks目录，在里面创建<code>post-receive</code>文件</p><pre><code class="language-shell">$ cd /srv/gitrepo/myblog.git/hooks
$ vim post-receive # 创建钩子文件
</code></pre><p>文件内容</p><pre><code class="language-shell">#!/bin/sh

unset GIT_DIR
path=/www/wwwroot/myblog/ #你的网站根目录，也是个git仓库，把你的项目从仓库中clone到这个地方
cd $path
git fetch --all
git reset --hard origin/master
</code></pre><p>以上操作是在git用户下执行的</p><p>给脚本增加运行权限</p><pre><code class="language-shell">chmod +x post-receive
</code></pre><p>创建完之后，运行一下看看有没有异常</p><pre><code class="language-shell">$ ./post-receive
</code></pre><p>如果出现异常，请查看一下，网站根目录是否输入git用户，具体就是权限的问题</p><ol><li>必须保证git用户的根目录的文件夹权限为 755 </li><li>必须保证git用户的根目录下的.ssh文件夹权限为 700 </li><li>必须保证git用户的根目录下的.ssh文件夹中的authorized_keys文件的权限为 600</li></ol><h3>大功告成！！！</h3><p>此时，你就可以写好博客然后push到Git仓库，TravisCI检测到你的分支发生变动，自动帮你执行<code>hexo g -d</code>的操作，然后把生成的文件提交Git仓库的master分支上，供Github Pages使用，还会提交一份到你的VPS Git仓库中，你的VPS Git仓库检测到有push行为，会触发Git Hooks，然后执行部署操作</p><p>有些地方描述的可能有些模糊，还请多去百度~~</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之eureka的搭建]]></title>
        <id>/SpringCloud-BuildEureka</id>
        <link href="https://ego1st.cn/SpringCloud-BuildEureka"/>
        <updated>2019-08-12T10:52:29.000Z</updated>
        <summary type="html"><![CDATA[Spring Cloud是目前用于开发微服务的主流框架之一，我们都知道在微服务架构中最为基础、核心的模块，就是服务注册与发现。在Spring Cloud里我们可以使用它的Eureka模块来实现服务注册与发现，Spring Cloud Eureka是基于Netflix Eureka做了二次封装，它主要负责完成各个微服务实例的自动化注册和发现功能。]]></summary>
        <content type="html"><![CDATA[<p>Spring Cloud是目前用于开发微服务的主流框架之一，我们都知道在微服务架构中最为基础、核心的模块，就是服务注册与发现。在Spring Cloud里我们可以使用它的Eureka模块来实现服务注册与发现，Spring Cloud Eureka是基于Netflix Eureka做了二次封装，它主要负责完成各个微服务实例的自动化注册和发现功能。  </p><p>Eureka由两个组件组成：</p><ol><li><p>Eureka Server（注册中心）</p></li><li><p>Eureka Client （服务注册）</p></li></ol><h2>Eurek Server搭建</h2><h3>在IDEA中新建一个Spring boot项目</h3><p>填写项目名之后，添加依赖，选择Spring Cloud Discovery--&gt;Eureka Server，如图：</p><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-12_11-00-21.jpg"/></p><p>pom.xml文件的依赖如下：</p><pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3>改主类</h3><p>在主类上添加<code>@EnableEurekaServer</code>注解</p><pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
//开启Eureka服务注册中心
@EnableEurekaServer
@SpringBootApplication
public class XinmusicEurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(XinmusicEurekaApplication.class, args);
    }

}
</code></pre><h3>配置application.yml</h3><pre><code class="language-yaml">server:
  port: 8081 # 服务端口号

eureka:
  instance:
    hostname: 127.0.0.1 # 注册中心IP地址
  client:
    registerWithEureka: false # 指定不进行注册操作，默认为true，若进行注册的话，会显示在Eureka信息面板上
    fetchRegistry: false # # 实例是否在eureka服务器上注册自己的信息以供其他服务发现，默认为true 如果是做高可用的发现服务那就要改成true
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 指定注册中心的地址
</code></pre><h3>启动</h3><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-12_11-23-22.jpg"/></p><h2>Eureka Client的使用</h2><h3>添加依赖</h3><p>在已有的项目中添加依赖，在pom.xml中添加依赖，如下：</p><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;


&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><h3>改主类</h3><p>在服务提供者项目主类上添加注解<code>@EnableDiscoveryClient</code>声明这是一个eureka client，进行服务注册</p><pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@EnableEurekaClient
@SpringBootApplication
public class XinmusicApplication {

    public static void main(String[] args) {
        SpringApplication.run(XinmusicApplication.class, args);
    }

}

</code></pre><h3>配置application.yml</h3><pre><code class="language-yml">eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:8081/eureka/  # eureka注册中心的地址
spring:
  application:
    name: music-list-service #服务名称--调用的时候根据名称来调用该服务的方法
server:
  port: 8082 # 该项目的启动端口
</code></pre><h3>启动</h3><p>启动后，在<code>Instances currently registered with Eureka</code>中可看到Eureka客户端的信息</p><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-12_11-40-27.jpg"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud之微服务]]></title>
        <id>/SpringCloud-Micro</id>
        <link href="https://ego1st.cn/SpringCloud-Micro"/>
        <updated>2019-08-09T17:42:35.000Z</updated>
        <summary type="html"><![CDATA[以下是我对SpringCloud中eureka服务注册与发现，服务提供者和服务消费者的理解]]></summary>
        <content type="html"><![CDATA[<p>以下是我对SpringCloud中eureka服务注册与发现，服务提供者和服务消费者的理解</p><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-12_10-34-58.jpg"/></p><p>大致流程就是，建立三个SpringBoot项目，分别为注册中心（eureka），服务提供者（提供restFul接口），服务消费者（feign）。服务提供者和服务消费者首先在eureka中注册自己，然后消费者通过注册中心发现服务提供者，然后通过service调用服务提供者的接口，然后返回对应的值，外部通过访问服务消费者的接口，以达到使用服务提供者的目的，其中，在注册中心可以注册多个相同的服务提供者，使用feign实现负载均衡。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[testGithooks]]></title>
        <id>/testGithooks</id>
        <link href="https://ego1st.cn/testGithooks"/>
        <updated>2019-08-08T14:44:22.000Z</updated>
        <summary type="html"><![CDATA[测试Githooks是否能够自动把代码部署到网站根目录]]></summary>
        <content type="html"><![CDATA[<h3>测试Githooks是否能够自动把代码部署到网站根目录</h3>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试TravisCI]]></title>
        <id>/testTravisCI</id>
        <link href="https://ego1st.cn/testTravisCI"/>
        <updated>2019-08-03T00:37:36.000Z</updated>
        <summary type="html"><![CDATA[这篇博客是采用git+TravisCI实现的自动化部署]]></summary>
        <content type="html"><![CDATA[<p>这篇博客是采用git+TravisCI实现的自动化部署</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot使用MyBaits]]></title>
        <id>/SpringBootError1</id>
        <link href="https://ego1st.cn/SpringBootError1"/>
        <updated>2019-08-02T17:59:33.000Z</updated>
        <summary type="html"><![CDATA[SpringBoot整合MyBatis使用过程中出现的错误]]></summary>
        <content type="html"><![CDATA[<h3>SpringBoot整合MyBatis使用过程中出现的错误</h3><p>错误<code>Invalid bound statement (not found)</code></p><p>如图所示：</p><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-02_17-33-39.jpg" alt="报错信息"/></p><p>网上找了几种解决办法：</p><ol><li><p>检查<code>xxxmapper.xml</code>文件中的<code>namespace</code>路径是否正确，是否是Mapper interface所在的包名</p></li><li><p><code>xxxmapper</code>类中的方法在<code>xxxmapper.xml</code>中是否存在（用逆向工程生成的一般没这个问题）</p></li><li><p><code>xxxmapper</code>类的方法返回值是<code>List&lt;User&gt;</code>而<code>select</code>元素没有正确配置<code>ResultMap</code>，或者只配置<code>ResultType</code></p></li><li><p>如果你确认没有以上问题,请任意修改下对应的xml文件,比如删除一个空行,保存.问题解决（待求证）</p></li><li><p>在<code>application.yml</code>中mybatis的配置路径是否正确</p><pre><code class="language-yaml">## 该配置节点为独立的节点，有很多同学容易将这个配置放在spring的节点下，导致配置无法被识别
mybatis:
#注意：一定要对应mapper映射xml文件的所在路径
  mapper-locations: classpath:com.ego14t.xinmusic.mapper/*.xml  
#注意：对应实体类的路径
  type-aliases-package: com.ego14t.xinmusic.pojo  
</code></pre></li></ol><h4>我的问题出现在了第五条，但是！！！改完之后运行还是不行。。。</h4><p>   在我打开<code>target</code>目录之后，发现</p><p>   <img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-08-02_17-54-09.jpg" alt="target目录"/></p><p><code>mapper</code>目录下并没有生成xml文件，百度之后得知，IDEA默认不会生成xml文件，需要修改一下<code>pom.xml</code>文件，修改如下：</p><pre><code class="language-xml">&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
        &lt;resources&gt;
            &lt;!--让idea生成xml文件--&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;true&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre><p>在更新完之后，重新运行项目</p><h4>问题解决！！！</h4>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring中使用Swagger文档]]></title>
        <id>/SpringBoot-UseSwagger</id>
        <link href="https://ego1st.cn/SpringBoot-UseSwagger"/>
        <updated>2019-07-31T14:20:18.000Z</updated>
        <summary type="html"><![CDATA[Swagger是一个简单但功能强大的API表达工具。它具有地球上最大的API工具生态系统，数以千计的开发人员，使用几乎所有的现代编程语言，都在支持和使用Swagger。使用Swagger生成API，我们可以得到交互式文档，自动生成代码的SDK以及API的发现特性等。]]></summary>
        <content type="html"><![CDATA[<p>Swagger是一个简单但功能强大的API表达工具。它具有地球上最大的API工具生态系统，数以千计的开发人员，使用几乎所有的现代编程语言，都在支持和使用Swagger。使用Swagger生成API，我们可以得到交互式文档，自动生成代码的SDK以及API的发现特性等。<br/>
<!-- -->现在，Swagger已经帮助包括Apigee, Getty图像, Intuit, LivingSocial, McKesson, 微软, Morningstar和PayPal等世界知名企业建立起了一套基于RESTful API的完美服务系统。<br/>
<!-- -->2.0版本已经发布，Swagger变得更加强大。值得感激的是，Swagger的源码100%开源在github。
<img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-07-30_09-36-02.jpg" alt="swagger"/></p><h2>在Spring中使用Swagger文档</h2><h3>导包</h3><p>在SpringBoot的pom.xml文件中加入依赖，空串问题在另一篇blog有写</p><pre><code class="language-xml">        &lt;!-- Swagger2 Api插件 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
            &lt;!--排除swagger-models1.5.20版本，解决空串问题--&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;io.swagger&lt;/groupId&gt;
                    &lt;artifactId&gt;swagger-models&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!--导入swagger-models1.5.22版本，解决空串问题--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.swagger&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-models&lt;/artifactId&gt;
            &lt;version&gt;1.5.22&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><h3>配置Swagger</h3><h4>在项目中<code>Application.java</code>同级创建Swagger的配置类</h4><pre><code class="language-java">@Component
// 开启Swagger2的自动配置
@EnableSwagger2
public class Swagger2Config {
    
}
</code></pre><h4>配置Swagger实例</h4><p>Swagger实例Bean是Docket，所以通过配置Docket实例来配置Swaggger</p><pre><code class="language-java">@Bean
    public Docket creatRestApi(){
        
        return new Docket(DocumentationType.SWAGGER_2);
        
    }
</code></pre><p>然后启动项目，打开<code>http://localhost:8080/swagger-ui.html</code>即可看到接口文档</p><p><img src="https://cdn.ego1st.cn/postImg/swagger%E9%A1%B5%E9%9D%A2.jpg" alt="Swagger文档页面"/></p><h4>配置要扫描的接口</h4><pre><code class="language-java">@Bean
    public Docket creatRestApi(){

        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .apis(RequestHandlerSelectors
                .basePackage(&quot;com.ego14t.xinmusic.controller&quot;)) //Controller所在的包
                .build();

    }
</code></pre><p><code>RequestHandlerSelectors</code>中还有一些其他的扫描方式</p><ol><li><code>any()</code> ：扫描所有，项目中的所有接口都会被扫描到</li><li><code>none()</code>：不扫描接口</li><li><code>withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</code>：通过在方法上注解扫描如withMethodAnnotation(GetMapping.class)只扫描get请求</li><li><code>withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</code>：通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</li></ol><h4>配置Api文档信息</h4><pre><code class="language-java">    //配置文档信息
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;昕音乐Api文档&quot;)
                .description(&quot;优雅的Api文档&quot;)
                .version(&quot;1.0&quot;)
                .build();

    }
</code></pre><p>具体可以配置的参数如下：</p><pre><code class="language-java">    //联系人信息 name，url，email
    public static final Contact DEFAULT_CONTACT = new Contact(&quot;&quot;, &quot;&quot;, &quot;&quot;);
    public static final ApiInfo DEFAULT;//默认值
    private final String version;//版本号
    private final String title;//标题
    private final String description;//接口描述
    private final String termsOfServiceUrl;//组织链接
    private final String license;//许可
    private final String licenseUrl;//许可链接
    private final Contact contact;//联系人
    private final List&lt;VendorExtension&gt; vendorExtensions;
</code></pre><h3>完成</h3><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-07-30_09-36-02.jpg" alt="swagger"/></p><h3>Api的详细信息配置</h3><ol><li><code>@Api</code>：作用于控制器类上，标识这个类是Swagger资源，tags值会在页面显示</li></ol><pre><code class="language-java">@Api(value = &quot;歌单Controller&quot;,tags = {&quot;歌单操作类接口&quot;})
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-07-30_09-44-35.jpg"/></p><ol start="2"><li><p><code>@ApiOperation</code>：作用于方法上，表示一个http请求的操作，value用于方法描述 ，notes用于提示内容</p><pre><code class="language-java">//tags会添加分组，视情况用
@ApiOperation(value=&quot;根据歌单id返回歌曲列表&quot;,tags={&quot;&quot;},notes=&quot;注意问题点&quot;)
</code></pre><p><img src="https://cdn.ego1st.cn/postImg/Snipaste_2019-07-30_09-55-36.jpg"/></p></li><li><p><code>@ApiImplicitParams() </code>：用于方法，参数，字段说明，标识请求参数name参数名，value参数说明，dataType数据类型 ，paramType参数类型 ，example–举例说明，required是否必填</p><pre><code class="language-java">@ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;id&quot;, value = &quot;歌单ID&quot;, required = true, dataType = &quot;int&quot;)
</code></pre><pre><code class="language-java">@ApiImplicitParams({
  @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;id&quot;, value = &quot;歌单ID&quot;, required = true, dataType = &quot;int&quot;),
  @ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;username&quot;, value = &quot;用户名&quot;, required = true, dataType = &quot;String&quot;)})
</code></pre></li><li><p><code>ApiImplicitParam</code>中的<code>paramType</code>参数</p><table><thead><tr><th>paramType参数</th><th>请求参数的获取</th></tr></thead><tbody><tr><td>header</td><td>@RequestHeader(代码中接收注解)</td></tr><tr><td>query</td><td>@RequestParam(代码中接收注解)</td></tr><tr><td>path（用于restful接口）</td><td>@PathVariable(代码中接收注解)</td></tr><tr><td>body</td><td>@RequestBody(代码中接收注解)</td></tr></tbody></table></li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySql时间类型]]></title>
        <id>/MySqlTimeType</id>
        <link href="https://ego1st.cn/MySqlTimeType"/>
        <updated>2019-07-31T08:37:40.000Z</updated>
        <summary type="html"><![CDATA[MySql 时间类型]]></summary>
        <content type="html"><![CDATA[<h2>MySql 时间类型</h2><p>Mysql中经常用来存储日期的数据类型有三种：<code>Date</code>、<code>Datetime</code>、<code>Timestamp</code>。</p><p><code>Date数据类型</code>：<code>用来存储没有时间的日期。</code>Mysql获取和显示这个类型的格式为“YYYY-MM-DD”。支持的时间范围为“1000-00-00”到“9999-12-31”。</p><p><code>Datetime类型</code>：<code>存储既有日期又有时间的数据。</code>存储和显示的格式为 “YYYY-MM-DD HH:MM:SS”。支持的时间范围是“1000-00-00 00:00:00”到“9999-12-31 23:59:59”。</p><p><code>Timestamp类型</code>：<code>也是存储既有日期又有时间的数据。</code>存储和显示的格式为 “YYYY-MM-DD HH:MM:SS”。支持的时间范围是“1970-01-01 00:00:01”到“2038-01-19 03:14:07”。</p><p>所有不符合上面所述格式的数据都会被转换为相应类型的0值。（0000-00-00或者0000-00-00 00:00:00）  </p><h3>datetime和timestamp的区别</h3><table><thead><tr><th align="left"></th><th align="center">占用空间</th><th align="center">表示范围</th><th align="center">时区</th></tr></thead><tbody><tr><td align="left">datetime</td><td align="center">8字节</td><td align="center">&#x27;1000-01-01 00:00:00.000000&#x27; to &#x27;9999-12-31 23:59:59.999999&#x27;</td><td align="center">不会进行时区的检索</td></tr><tr><td align="left">timestamp</td><td align="center">4字节</td><td align="center">&#x27;1970-01-01 00:00:01.000000&#x27; to &#x27;2038-01-19 03:14:07.999999&#x27;</td><td align="center">自动检索当前时区并进行转换</td></tr></tbody></table><p>还有一点就是，如果存进去的数据是null，timestamp会存储当前的时间，而datetime会存储为null</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swagger空串错误]]></title>
        <id>/SwaggerNullError</id>
        <link href="https://ego1st.cn/SwaggerNullError"/>
        <updated>2019-07-30T17:40:35.000Z</updated>
        <summary type="html"><![CDATA[关于Swagger2的踩坑]]></summary>
        <content type="html"><![CDATA[<h2>关于Swagger2的踩坑</h2><p>今天在项目中加入了swagger Api文档生成工具，项目启动无异常，但是在try it out的时候，填写好值之后，点击Execute之后，测试正常返回数据，但是在控制台会报出空串错误：<code>java.lang.NumberFormatException: For input string: &quot;&quot;</code></p><pre><code class="language-java">java.lang.NumberFormatException: For input string: &quot;&quot;
    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) ~[na:1.8.0_201]
    at java.lang.Long.parseLong(Long.java:601) ~[na:1.8.0_201]
    at java.lang.Long.valueOf(Long.java:803) ~[na:1.8.0_201]
    at io.swagger.models.parameters.AbstractSerializableParameter.getExample(AbstractSerializableParameter.java:412) ~[swagger-models-1.5.20.jar:1.5.20]
</code></pre><h2>解决办法：</h2><h3>方法1.在@ApiImplicitParam注解中，加入example属性及值</h3><pre><code class="language-java">@ApiImplicitParam(paramType=&quot;query&quot;, name = &quot;id&quot;, value = &quot;歌单ID&quot;, required = true, dataType = &quot;int&quot;,
example = &quot;123&quot;)
</code></pre><h3>方法2.排除<code>springfox-swagger2</code>中的<code>swagger-models 1.5.20</code>版本，替换为1.5.21版本</h3><p>在pom文件中加入排除，如图：</p><p><img src="https://cdn.ego1st.cn/postImg/swagger-4.jpg"/></p><p>然后导入新版的<code>swagger-models</code></p><pre><code class="language-xml">          &lt;dependency&gt;
            &lt;groupId&gt;io.swagger&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-models&lt;/artifactId&gt;
            &lt;version&gt;1.5.22&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><p>问题解决</p><h2>原因：</h2><p>如果example没有写值的话，默认是空串&quot;&quot; ,且不为空。<img src="https://cdn.ego1st.cn/postImg/swagger-3.jpg"/></p><p><img src="https://cdn.ego1st.cn/postImg/swagger-2.jpg"/></p><p>因为 空字符串<code>&quot;&quot;</code>无法转成<code>Number</code>所以抛出异常</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot搭建遇到的问题]]></title>
        <id>/DataBaseConnectError</id>
        <link href="https://ego1st.cn/DataBaseConnectError"/>
        <updated>2019-07-26T08:15:40.000Z</updated>
        <summary type="html"><![CDATA[关于数据库连接的问题]]></summary>
        <content type="html"><![CDATA[<h3>关于数据库连接的问题</h3><h2>SpringBoot的搭建</h2><h3>数据库连接报错</h3><pre><code class="language-Java">Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
</code></pre><h4>解决办法：</h4><p>将application.yml中数据库配置段<br/>
<!-- -->driver-class-name:  com.mysql.jdbc.Driver<!-- --> <!-- --> <!-- --> <br/>
<!-- -->改为com.mysql.cj.jdbc.Driver(多了个cj)</p><h4>原因：</h4><p>mysql的驱动类位置改变了  </p><h3>数据库时区问题</h3><pre><code class="language-java">erver time zone value &#x27;�й���׼ʱ��&#x27; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.
</code></pre><h4>解决办法</h4><p>在数据库连接的url链接后加上&quot;&amp;serverTimezone=GMT%2B8&quot;</p><h4>原因</h4><p>mysql默认的是美国的时区，比我们中国快8小时，所以我们采用+8:00的格式</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-Day02]]></title>
        <id>/VueDay02</id>
        <link href="https://ego1st.cn/VueDay02"/>
        <updated>2019-07-23T14:30:55.000Z</updated>
        <summary type="html"><![CDATA[Vue笔记&ensp;Day2]]></summary>
        <content type="html"><![CDATA[<h2>Vue笔记<!-- --> <!-- -->Day2</h2><h2>Vue事件修饰符</h2><h3>“.stop”<!-- --> <!-- -->阻止冒泡事件</h3><pre><code class="language-html">&lt;!--当出发Button的点击事件后，会立即触发div的点击事件--&gt;
        &lt;div class=&#x27;inner&#x27; @click=&#x27;div1Handler&#x27;&gt;
            &lt;!-- 用.stop 阻止冒泡--&gt;
            &lt;input type=&quot;button&quot; value=&quot;Button1&quot; @click.stop=&#x27;btnHandler&#x27;&gt;
        &lt;/div&gt;
</code></pre><h3>“.prevent”<!-- --> <!-- -->阻止默认事件</h3><pre><code class="language-html">&lt;!--当触发Button点击事件后，会阻止默认事件，即不触发a标签跳转事件--&gt;
        &lt;a href=&quot;http://www.google.com&quot; class=&quot;href&quot;  
        @click.prevent=&#x27;linkClick&#x27;&gt;Google&lt;/a&gt;
</code></pre><h3>“.capture”<!-- --> <!-- -->与冒泡事件正好相反，从外向内触发事件</h3><pre><code class="language-html">&lt;!--使用capture实现触发事件的机制 先触发divHandler，再触发btnHandler--&gt;
        &lt;div class=&quot;inner&quot; @click.capture=&#x27;div1Handler&#x27;&gt;
            &lt;input type=&quot;button&quot; value=&quot;Button2&quot; @click=&#x27;btnHandler&#x27;&gt;
        &lt;/div&gt;
</code></pre><h3>“.self”<!-- --> <!-- -->只有点自己才会执行</h3><pre><code class="language-html">&lt;!--使用self实现自己单独执行，不触发冒泡事件--&gt;
        &lt;div class=&quot;inner&quot; @click.self=&#x27;div1Handler&#x27;&gt; 
            &lt;input type=&quot;button&quot;  value=&quot;Button3&quot; @click=&#x27;btnHandler&#x27;&gt;
        &lt;/div&gt;
</code></pre><h3>“.once”<!-- --> <!-- -->只执行一次，可与其他修饰符串联，如：</h3><pre><code class="language-html">&lt;!--串联修饰符， 阻止一次事件触发 使用once, prevent可以触发一次事件处理函数--&gt;
        &lt;a href=&quot;http://www.baidu.com&quot;  
        @click.once.prevent=&#x27;linkClick&#x27;&gt;Baidu&lt;/a&gt;
        &lt;!--或者--&gt;
        &lt;a href=&quot;http://www.baidu.com&quot;  
        @click.prevent.once=&#x27;linkClick&#x27;&gt;Baidu&lt;/a&gt;
</code></pre><h3>“.self”与“.stop”的区别</h3><ul><li>.stop:阻止所有的冒泡行为  </li></ul><pre><code class="language-html">&lt;!--点击button不会向外冒泡触发其他外层事件--&gt;
    &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt;
        &lt;div class=&quot;inner&quot; @click=&quot;div1Handler&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;ButtonSTOP&quot; @click.stop=&#x27;btnHandler&#x27;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
</code></pre><ul><li>.self:只会阻止自己的冒泡行为  </li></ul><pre><code class="language-html">&lt;!--点击button，向外冒泡触发，inner事件有self修饰故不触发，然后触发outer的事件--&gt;
    &lt;div class=&quot;outer&quot; @click=&quot;div2Handler&quot;&gt;
        &lt;div class=&quot;inner&quot; @click.self=&quot;div1Handler&quot;&gt;
            &lt;input type=&quot;button&quot; value=&quot;Button&quot; @click=&#x27;btnHandler&#x27;&gt;
        &lt;/div&gt;
    &lt;/div&gt; 
</code></pre><h2>v-bind与v-model</h2><h3>先上一段代码：</h3><pre><code class="language-html">&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;h4&gt;{{msg}}&lt;/h4&gt;
        &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; style=&quot;width: 100%; &quot;&gt; 
        &lt;input type=&quot;text&quot; v-model:value=&#x27;msg&#x27; style=&#x27;width: 100%;&#x27;&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var vm = new Vue(
            {
                el: &#x27;#app&#x27;,
                data: {
                    msg: &#x27;I am a message&#x27;,
                },
            }
        )
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><ul><li>v-bind只能实现数据的单向绑定</li><li>v-model可以实现数据的双向绑定，v-model只能运用在表单元素中  </li></ul><h3>v-bind:</h3><p><img src="https://cdn.ego1st.cn/postImg/v-bind.gif" alt="v-bind"/><br/>
<!-- -->修改v-bind绑定的文本框的值，并不会改变msg的值  </p><h3>v-model:</h3><p><img src="https://cdn.ego1st.cn/postImg/v-model.gif" alt="v-model"/><br/>
<!-- -->修改v-model绑定的文本框的值，会改变msg的值，vue监听到data属性中msg值的改变，从而改变v-bind绑定的文本框的值<br/>
<!-- -->v-model---&gt;改变msg---&gt;改变v-model</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-Day01]]></title>
        <id>/vueDay01</id>
        <link href="https://ego1st.cn/vueDay01"/>
        <updated>2019-07-22T10:05:00.000Z</updated>
        <summary type="html"><![CDATA[Vue 笔记&ensp;Day1]]></summary>
        <content type="html"><![CDATA[<h2>Vue 笔记<!-- --> <!-- -->Day1</h2><h2>Vue指令</h2><ol><li>插值表达式会去data里寻找插值表达式中的变量对应的值</li><li>v-cloak<!-- --> <!-- --> <!-- --> <!-- --> <!-- -->可以解决插值表达式闪烁的问题</li><li>v-text<!-- --> <!-- --> <!-- --> <!-- --> <!-- -->把msg1解析成字符串输出 </li></ol><pre><code class="language-html">v-text=&quot;msg1&quot;
</code></pre><ol start="4"><li>v-html<!-- --> <!-- --> <!-- --> <!-- --> <!-- -->把msg2当作html语句进行输出 </li></ol><pre><code class="language-html">v-html=&quot;msg2&quot;
</code></pre><ol start="5"><li>v-bind<!-- --> <!-- --> <!-- --> <!-- --> <!-- -->vue中，提供用于绑定属性的指令,v-bind中可以写合法的Js表达式</li></ol><pre><code class="language-html">v-bind:title=&quot;mytitle&quot;  //v-bind可简写成:
:title=&quot;mytitle+&#x27;123&#x27;&quot;  //显示为mytitle123
</code></pre><ol start="6"><li>v-on<!-- --> <!-- --> <!-- --> <!-- --> <!-- -->vue中提供的事件绑定机制</li></ol><pre><code class="language-html">v-on:click=&quot;show&quot; //v-on可简写成@
</code></pre><ol start="7"><li>v-model<!-- --> <!-- --> <!-- --> <!-- --> <!-- -->实现表单输入和应用状态之间的双向绑定，只能用于表单元素</li></ol><pre><code class="language-html">&lt;p&gt;{{ message }}&lt;/p&gt;&lt;input v-model=&quot;message&quot;&gt;
</code></pre><h3>插值表达式与v-text的不同</h3><ol><li>v-text会覆盖元素中原本的内容<br/>插值表达式只会把占位符对应的值替换掉（+{{msg}}+）输出+123+，而不会把原本的内容清空</li><li>v-text不会出现闪烁问题，但是会把标记内内容清空</li></ol><h3>Vue的基本代码</h3><pre><code class="language-html">&lt;!DOCTYPE html&gt; 
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;./lib/vue.js&quot;&gt;&lt;/script&gt; 
  &lt;/head&gt;
  &lt;body&gt;


    &lt;!--将来new的Vue的实例会控制这个元素的所有内容--&gt;
    &lt;div id=&quot;app&quot;&gt;

    &lt;/div&gt;
    &lt;script&gt;

      var vm = new Vue({
        el: &quot;#app&quot;, //当前我们new的这个Vue实例要控制页面上的哪个区域
        data: {
          //data属性中，参访的是el中要用到的数据
          msg: &quot;HelloWorld&quot;,
          msg2:&#x27;&lt;h1&gt;I am the H1 tag &lt;/h1&gt;&#x27;,
          mytitle: &#x27;这是一个自己定义的title&#x27; 
        },
        methods: { 
          //v-on绑定的事件在Vue的methods属性内定义
          show: function(){
            alert(&#x27;hello&#x27;);
          }
        },
      });

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
    </entry>
</feed>